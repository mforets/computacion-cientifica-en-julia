var documenterSearchIndex = {"docs":
[{"location":"Fundamentos/Reglas de alcance/#Reglas-de-alcance","page":"Reglas de alcance","title":"Reglas de alcance","text":"","category":"section"},{"location":"Fundamentos/Reglas de alcance/#Variables","page":"Reglas de alcance","title":"Variables","text":"","category":"section"},{"location":"Fundamentos/Reglas de alcance/#Módulos","page":"Reglas de alcance","title":"Módulos","text":"","category":"section"},{"location":"Fundamentos/Reglas de alcance/","page":"Reglas de alcance","title":"Reglas de alcance","text":"–","category":"page"},{"location":"Fundamentos/Reglas de alcance/#Ejercicios","page":"Reglas de alcance","title":"Ejercicios","text":"","category":"section"},{"location":"Fundamentos/Metaprogramacion/#Metaprogramacion","page":"Metaprogramación","title":"Metaprogramacion","text":"","category":"section"},{"location":"Fundamentos/Metaprogramacion/#Macros","page":"Metaprogramación","title":"Macros","text":"","category":"section"},{"location":"Fundamentos/Metaprogramacion/#Lenguajes-específicos-de-dominio-(DSL)","page":"Metaprogramación","title":"Lenguajes específicos de dominio (DSL)","text":"","category":"section"},{"location":"Fundamentos/Metaprogramacion/","page":"Metaprogramación","title":"Metaprogramación","text":"","category":"page"},{"location":"Fundamentos/Metaprogramacion/#Ejercicios","page":"Metaprogramación","title":"Ejercicios","text":"","category":"section"},{"location":"Ecosistema/graficos_pub/#Gráficos-para-publicaciones","page":"Gráficos para publicaciones","title":"Gráficos para publicaciones","text":"","category":"section"},{"location":"Fundamentos/Funciones/#Funciones","page":"Funciones","title":"Funciones","text":"","category":"section"},{"location":"Fundamentos/Funciones/#Despacho-múltiple","page":"Funciones","title":"Despacho múltiple","text":"","category":"section"},{"location":"Fundamentos/Funciones/","page":"Funciones","title":"Funciones","text":"","category":"page"},{"location":"Fundamentos/Funciones/#Entregable-x-(borrador)","page":"Funciones","title":"Entregable x (borrador)","text":"","category":"section"},{"location":"Fundamentos/Funciones/#x.1.-Evaluación-de-polinomios-por-el-método-de-Bernstein","page":"Funciones","title":"x.1. Evaluación de polinomios por el método de Bernstein","text":"","category":"section"},{"location":"Fundamentos/Funciones/","page":"Funciones","title":"Funciones","text":"En este ejercicio revisitamos el problema del cálculo de coeficientes de Bernstein del Ejercicio 3.2, generalizando el cálculo a múltiples dimensiones.  Utilizamos multi-índices i = (i_1 i_2 ldots i_n) para representar n-tuplas de números enteros no negativos (lo mismo con l). Sea p mathbbR^n to mathbbR un polinomio multivariado (en n variables). Dado un polinomio en su forma canónica (es decir en la base de potencias),","category":"page"},{"location":"Fundamentos/Funciones/","page":"Funciones","title":"Funciones","text":"p(x) = sum_i=0^l a_i x^iqquad x = (x_1 ldots x_n)","category":"page"},{"location":"Fundamentos/Funciones/","page":"Funciones","title":"Funciones","text":"nos interesa expresarlo en una base diferente llamada la base de Bernstein. Gráficos de los polinomios de la base de Bernstein, B_i^l(x), se pueden apreciar en la Figura 3.1 de Enclosure Methods for Systems of Polynomial Equations and Inequalities de A. P. Smith (2012). En este ejercicio se debe implementar la ecuación (3.13) en dicha tesis, es decir, aquella que permite encontrar los coeficientes de p en la base de Bernstein,","category":"page"},{"location":"Fundamentos/Funciones/","page":"Funciones","title":"Funciones","text":"p(x) = sum_i=0^l b_i B_i^l(x)","category":"page"},{"location":"Fundamentos/Funciones/","page":"Funciones","title":"Funciones","text":"donde b_i son los coeficientes de Bernstein a determinar. Por conveniencia incluímos aquí la mencionada fórmula:","category":"page"},{"location":"Fundamentos/Funciones/","page":"Funciones","title":"Funciones","text":"b_i = sum_j=0^i dfracbinomijbinomlj(barx - underlinex)^j sum_k=j^l binomkjunderlinex^k-ja_kqquad 0 leq i leq l","category":"page"},{"location":"Fundamentos/Funciones/","page":"Funciones","title":"Funciones","text":"Sea X = underlinex_1 barx_1 times cdots times underlinex_n barx_n = underlinex barx un dominio rectangular (\"caja\").","category":"page"},{"location":"Fundamentos/Funciones/","page":"Funciones","title":"Funciones","text":"Implementar una función bernstein_coefficients(pol, X) que recibe un polinomio definido en el paquete DynamicPolynomials.jl y devuelve los coeficientes de Bernstein (b_i) asociados de grado l (para l suficientemente grande) en el dominio X.","category":"page"},{"location":"Fundamentos/Funciones/#x.2.-Pretty-printing","page":"Funciones","title":"x.2. Pretty printing","text":"","category":"section"},{"location":"Fundamentos/Funciones/","page":"Funciones","title":"Funciones","text":"Considerar nuevamente el ejercicio 2.2 Traducción de ARN e implementar las funciones necesarias para que las cadenas proteicas se impriman de manera más sencilla pero sin modificar el struct.","category":"page"},{"location":"Fundamentos/Funciones/","page":"Funciones","title":"Funciones","text":"Ejemplos:","category":"page"},{"location":"Fundamentos/Funciones/","page":"Funciones","title":"Funciones","text":"julia> traducir(ARN(\"CCU\"))\nCadenaProteica(\"Pro\")\n\njulia> traducir(ARN(\"AUGCCAAAGGGUUGA\"))\nCadenaProteica(\"MetProLysGly\")\n\njulia> traducir(ARN(\"GCAAGAGAUAAUUGU\"))\nCadenaProteica(\"AlaArgAspAsnCys\")","category":"page"},{"location":"proyectos/#Proyectos-Curso-2023","page":"Proyectos","title":"Proyectos Curso 2023","text":"","category":"section"},{"location":"proyectos/","page":"Proyectos","title":"Proyectos","text":"Nombre Título Link\n  ","category":"page"},{"location":"proyectos/#Proyectos-Curso-2022","page":"Proyectos","title":"Proyectos Curso 2022","text":"","category":"section"},{"location":"proyectos/","page":"Proyectos","title":"Proyectos","text":"Nombre Título Link\nFederico Bliman Problemas de SLAM SLAM_test.jl\nDaniel Gomez Localización de fallas en sistemas eléctricos de potencia Powerdistancer\nFederico Licandro Problemas de transferencia de calor transferencia_interactivo\nRodrigo Perdomo Localización de fallas en sistemas eléctricos de potencia Powerdistancer\nJuan Pedro Tarigo Predictability en sistemas de Mackey-Glass MGpredictability\nMauricio Vanzulli Identifación de propiedades materiales Apolo.jl\nJoaquin Viera Problemas de no linealidad material materialNonLinearity.jl","category":"page"},{"location":"Fundamentos/Gestor de paquetes/#Gestor-de-paquetes","page":"Gestor de paquetes","title":"Gestor de paquetes","text":"","category":"section"},{"location":"Fundamentos/Gestor de paquetes/","page":"Gestor de paquetes","title":"Gestor de paquetes","text":"–","category":"page"},{"location":"Fundamentos/Gestor de paquetes/#Ejercicios","page":"Gestor de paquetes","title":"Ejercicios","text":"","category":"section"},{"location":"Patrones/paquetes/#Generacion-de-paquetes","page":"Generación de paquetes","title":"Generacion de paquetes","text":"","category":"section"},{"location":"Patrones/paquetes/#Generación-de-tests","page":"Generación de paquetes","title":"Generación de tests","text":"","category":"section"},{"location":"Patrones/paquetes/#Integracion-continua","page":"Generación de paquetes","title":"Integracion continua","text":"","category":"section"},{"location":"Patrones/paquetes/#Registro-general","page":"Generación de paquetes","title":"Registro general","text":"","category":"section"},{"location":"Patrones/paquetes/","page":"Generación de paquetes","title":"Generación de paquetes","text":"","category":"page"},{"location":"Patrones/paquetes/#Entregable-7","page":"Generación de paquetes","title":"Entregable 7","text":"","category":"section"},{"location":"Patrones/paquetes/#.1.-Preparación-del-proyecto","page":"Generación de paquetes","title":"7.1. Preparación del proyecto","text":"","category":"section"},{"location":"Patrones/paquetes/","page":"Generación de paquetes","title":"Generación de paquetes","text":"Genere un nuevo repositorio en GitHub (u otro servicio) que utilizará para su proyecto de curso. El proyecto puede ser público o privado (en ese último caso debe dar accesso a los docentes). Deberá agregar un esqueleto del proyecto como recomendado en clase, asi como también esqueleto para documentación y tests. Puede agregar dependencias que considere necesarias.","category":"page"},{"location":"Patrones/docs/#Entregable-8","page":"Documentación de código","title":"Entregable 8","text":"","category":"section"},{"location":"Patrones/docs/#Definición-de-interfases-del-proyecto-final","page":"Documentación de código","title":"Definición de interfases del proyecto final","text":"","category":"section"},{"location":"Patrones/docs/","page":"Documentación de código","title":"Documentación de código","text":"El objetivo de este último entregable es definir qué interfases va a utilizar en su proyecto.","category":"page"},{"location":"Patrones/docs/","page":"Documentación de código","title":"Documentación de código","text":"Por ejemplo, en la clase del viernes 14-10 estudiamos las interfaces AbstractSolver, AbstractProblem y AbstractSolution para modelar el algoritmo, el problema y la solucion respectivamente.","category":"page"},{"location":"Patrones/docs/","page":"Documentación de código","title":"Documentación de código","text":"La idea del ejercicio no es profundizar en los detalles de la implementacion, sino pensar, a alto nivel, en las distintas componentes de su proyecto y cómo se pasan los datos entre ellas.","category":"page"},{"location":"Patrones/docs/","page":"Documentación de código","title":"Documentación de código","text":"El Entregable 8 sera particular a cada proyecto como anunciamos la ultima clase. Utilizaremos hackmd para la propuesta.","category":"page"},{"location":"Patrones/docs/#HackMD:","page":"Documentación de código","title":"HackMD:","text":"","category":"section"},{"location":"Patrones/docs/","page":"Documentación de código","title":"Documentación de código","text":"Como \"block de notas\" de cada proyecto creamos este espacio en HackMD. Deben hacerse un usuario en hackmd si no tienen.","category":"page"},{"location":"Patrones/docs/","page":"Documentación de código","title":"Documentación de código","text":"Una vez ingresados deberian ver un block con el nombre de su proyecto.","category":"page"},{"location":"ideas_proyecto/#Ideas-de-proyectos-curso-2022","page":"Ideas de proyectos curso 2022","title":"Ideas de proyectos curso 2022","text":"","category":"section"},{"location":"ideas_proyecto/#Expansión-de-Bernstein-implícita","page":"Ideas de proyectos curso 2022","title":"Expansión de Bernstein implícita","text":"","category":"section"},{"location":"ideas_proyecto/","page":"Ideas de proyectos curso 2022","title":"Ideas de proyectos curso 2022","text":"En este proyecto se plantea desarrollar un módulo para el cálculo del rango de polinomios multivariados utilizando la forma de Bernstein implícita, ver Enclosure Methods for Systems of Polynomial Equations and Inequalities de A. P. Smith (2012). Se buscará obtener una performance competitiva respecto del estado del arte. Ver por ejemplo la librería Kodiak de la NASA.","category":"page"},{"location":"ideas_proyecto/#Reachability-para-problemas-de-propagación-de-ondas","page":"Ideas de proyectos curso 2022","title":"Reachability para problemas de propagación de ondas","text":"","category":"section"},{"location":"ideas_proyecto/","page":"Ideas de proyectos curso 2022","title":"Ideas de proyectos curso 2022","text":"En este proyecto se plantea desarrollar un módulo que permita realizar cálculos de reachability (estados alcanzables) para problemas de propagación de ondas en medios elásticos. El módulo se apoyará en los resultados obtenidos en el artículo de Forets, Freire Caporale, Zerpa (2021), Combining set propagation with finite element methods for time integration in transient solid mechanics problems.","category":"page"},{"location":"ideas_proyecto/#Operaciones-con-conjuntos-no-convexos-para-CPS","page":"Ideas de proyectos curso 2022","title":"Operaciones con conjuntos no convexos para CPS","text":"","category":"section"},{"location":"ideas_proyecto/","page":"Ideas de proyectos curso 2022","title":"Ideas de proyectos curso 2022","text":"La propuesta de este proyecto es contribuir al desarrollo de la librería LazySets con funcionalidades necesarias para trabajar con conjuntos no convexos 1, 2. Se prestará particular atención a métodos necesarios para aplicar LazySets a problemas de control y sistemas ciber-physicos en 3, 4. Como conocimiento previo se requiere 5.","category":"page"},{"location":"ideas_proyecto/#Algoritmo-de-K-caminos-con-loops","page":"Ideas de proyectos curso 2022","title":"Algoritmo de K-caminos con loops","text":"","category":"section"},{"location":"ideas_proyecto/","page":"Ideas de proyectos curso 2022","title":"Ideas de proyectos curso 2022","text":"La propuesta de este proyecto es agregar un algoritmo utilizando la interfaz de Graphs.jl que implemente el método de Eppstein para encontrar los K caminos más cortos en un grafo dirigido con pesos. El algoritmo fue publicado en 1; ver también 2 para un enfoque más incremental en la metodología.","category":"page"},{"location":"Patrones/performance/#Patrones-para-performances","page":"Patrones para performance","title":"Patrones para performances","text":"","category":"section"},{"location":"Patrones/performance/#Profiling","page":"Patrones para performance","title":"Profiling","text":"","category":"section"},{"location":"Entregables/Entregable4/#Entregable-4","page":"Entregable 4","title":"Entregable 4","text":"","category":"section"},{"location":"Entregables/Entregable4/","page":"Entregable 4","title":"Entregable 4","text":"warning: Entrega\nSe debe entregar un archivo .ZIP llamado Entregable_4 que contenga un archivo de Julia (.jl) por cada ejercicio Ejercicio1.jl, Ejercicio2.jl, etc. Fecha límite de entrega: Viernes 21 de abril.","category":"page"},{"location":"Entregables/Entregable4/#.","page":"Entregable 4","title":"1.","text":"","category":"section"},{"location":"Entregables/Entregable4/","page":"Entregable 4","title":"Entregable 4","text":"Determinar si un tablero de sudoku de 9x9 es válido. El tablero no tiener por qué estar completo, para lo cual se utilizan entradas missing. El tablero se representa como una Matrix{Union{Missing, Int64}}.","category":"page"},{"location":"Entregables/Entregable4/","page":"Entregable 4","title":"Entregable 4","text":"Las reglas para determinar la validez del tablero son:","category":"page"},{"location":"Entregables/Entregable4/","page":"Entregable 4","title":"Entregable 4","text":"Cada fila debe contener los digitos de 1 a 9 sin repetición.\nCada columna debe contener los dígitos de 1 a 9 sin repetición.\nCada uno de las 3 x 3 bloques debe contener los dígitos de 1 a 9 sin repetición.\nLas entradas missing se ignoran.","category":"page"},{"location":"Entregables/Entregable4/","page":"Entregable 4","title":"Entregable 4","text":"Implementar valido(tablero::Matrix{Union{Missing, Int64}})::Bool de acuerdo a las reglas anteriores.","category":"page"},{"location":"Entregables/Entregable4/#.-2","page":"Entregable 4","title":"2.","text":"","category":"section"},{"location":"Entregables/Entregable4/","page":"Entregable 4","title":"Entregable 4","text":"Dada una matriz 2D de tamaño n times n que podría representar una imagen, implementar una función rotar! que rota la matriz 90º en sentido horario. ","category":"page"},{"location":"Entregables/Entregable4/","page":"Entregable 4","title":"Entregable 4","text":"Por ejemplo, dada la entrada ","category":"page"},{"location":"Entregables/Entregable4/","page":"Entregable 4","title":"Entregable 4","text":"[1 2 3; 4 5 6; 7 8 9]","category":"page"},{"location":"Entregables/Entregable4/","page":"Entregable 4","title":"Entregable 4","text":"el algoritmo debe producir la salida:","category":"page"},{"location":"Entregables/Entregable4/","page":"Entregable 4","title":"Entregable 4","text":"[7 4 1; 8 5 2; 9 6 3]","category":"page"},{"location":"Entregables/Entregable4/","page":"Entregable 4","title":"Entregable 4","text":"LLamar a dicha funcion rotar(x:Matrix{Int64})::Matrix{Int64}.","category":"page"},{"location":"Entregables/Entregable4/#.-3","page":"Entregable 4","title":"3.","text":"","category":"section"},{"location":"Entregables/Entregable4/","page":"Entregable 4","title":"Entregable 4","text":"Revisar el algoritmo del ejercicio 2, implementando un algoritmo que opere en el sitio, es decir que no cree ninguna matriz auxiliar, sino que opere sobre la misma matriz de entrada. LLamar a dichar funcion rotar!(x:Matrix{Int64})::Matrix{Int64}.","category":"page"},{"location":"Entregables/Entregable4/#.-4","page":"Entregable 4","title":"4.","text":"","category":"section"},{"location":"Entregables/Entregable4/","page":"Entregable 4","title":"Entregable 4","text":"Se adaptará el algoritmo desarrollado en el problema 2 (o 3) para rotar una imagen de verdad. Para ello, obtener una imagen cualquiera (puede ser desde el celular), cargarla y rotarla. El resultado del ejercicio es entonces implementar un nuevo metodo rotar(path::String)::String que recibe el path de una imagen, la rota, y la guarda en un archivo del mismo nombre que path pero agregando _rotada.","category":"page"},{"location":"Entregables/Entregable4/","page":"Entregable 4","title":"Entregable 4","text":"Código de ejemplo:","category":"page"},{"location":"Entregables/Entregable4/","page":"Entregable 4","title":"Entregable 4","text":"# Cargar una imagen de disco en memoria.\nusing Images, FileIO\n\npath = \"imagen.png\"\nimg = load(path)\n\n# Visualizar la imagen.\nusing ImageView\nimshow(img)\n\n# Aplicar operaciones.\n# ...\n\n# Guardar la imagen.\nsave(\"resultado.png\", img)","category":"page"},{"location":"Fundamentos/Tipos de datos basicos/#Tipos-de-datos-básicos","page":"Tipos de datos básicos","title":"Tipos de datos básicos","text":"","category":"section"},{"location":"Fundamentos/Tipos de datos basicos/","page":"Tipos de datos básicos","title":"Tipos de datos básicos","text":"–","category":"page"},{"location":"Fundamentos/Tipos de datos basicos/#Ejercicios","page":"Tipos de datos básicos","title":"Ejercicios","text":"","category":"section"},{"location":"Entregables/Entregable1/#Entregable-1","page":"Entregable 1","title":"Entregable 1","text":"","category":"section"},{"location":"Entregables/Entregable1/","page":"Entregable 1","title":"Entregable 1","text":"warning: Entrega\nSe debe entregar un archivo .ZIP llamado Entregable_1 que contenga un archivo de Julia (.jl) por cada ejercicio Ejercicio1.jl, Ejercicio2.jl, etc. Fecha límite de entrega: Jueves 23 de marzo.","category":"page"},{"location":"Entregables/Entregable1/#.","page":"Entregable 1","title":"1.","text":"","category":"section"},{"location":"Entregables/Entregable1/","page":"Entregable 1","title":"Entregable 1","text":"Escribir un programa que imprima en pantalla:","category":"page"},{"location":"Entregables/Entregable1/","page":"Entregable 1","title":"Entregable 1","text":"Los enteros de 1 hasta 100.\nLos multiplos de 2 entre 1 y 100.\nLos multiplos de 5 entre 1024 y 1200.","category":"page"},{"location":"Entregables/Entregable1/#.-2","page":"Entregable 1","title":"2.","text":"","category":"section"},{"location":"Entregables/Entregable1/","page":"Entregable 1","title":"Entregable 1","text":"Alberto vende cursos de programación online y los promociona con un gasto fijo de 200 usd en publicidad. Por cada alumno que compra un curso Alberto gana 12 usd. Escribir una función f(x) que modele los ingresos de alberto si x es la cantidad de alumnos que compran su curso.","category":"page"},{"location":"Entregables/Entregable1/#.-3","page":"Entregable 1","title":"3.","text":"","category":"section"},{"location":"Entregables/Entregable1/","page":"Entregable 1","title":"Entregable 1","text":"Escribir un programa que dada una cadena de caracteres (String) imprima todas las combinaciones posibles de tres letras. Por ejemplo para la palabra \"sol\" el output seria:","category":"page"},{"location":"Entregables/Entregable1/","page":"Entregable 1","title":"Entregable 1","text":"julia> combinaciones(\"sol\")\n6-element Vector{String}:\n \"sol\"\n \"slo\"\n \"osl\"\n \"ols\"\n \"lso\"\n \"los\"","category":"page"},{"location":"Entregables/Entregable1/#.-4","page":"Entregable 1","title":"4.","text":"","category":"section"},{"location":"Entregables/Entregable1/","page":"Entregable 1","title":"Entregable 1","text":"Dado un angulo theta escribir su respectiva matriz de rotación (2x2). Calcular la imagen del vector [1, 0] cuando teta toma valores entre [0, pi/2, pi, 1].","category":"page"},{"location":"Entregables/Entregable1/#.-5","page":"Entregable 1","title":"5.","text":"","category":"section"},{"location":"Entregables/Entregable1/","page":"Entregable 1","title":"Entregable 1","text":"Al comienzo de 2023 Juana deposita C pesos en un banco con una taza de interés r (entre 0 y 1).La capitalizacion es continua. Escribir una funcion g(Crx) que modele el interés. ¿Si C = 100000 y r = 005, cuánto es el capital de Juana pasados 18 meses?","category":"page"},{"location":"#Generalidades","page":"Generalidades","title":"Generalidades","text":"","category":"section"},{"location":"#Objetivos","page":"Generalidades","title":"Objetivos","text":"","category":"section"},{"location":"","page":"Generalidades","title":"Generalidades","text":"Los objetivos principales consisten en presentar los conceptos básicos de la computación científica moderna mediante el lenguaje de programación Julia y su ecosistema de código abierto. Asimismo, se brindarán nociones y patrones de diseño que faciliten el uso de herramientas computacionales para la generación de códigos mantenibles, eficientes y reproducibles.","category":"page"},{"location":"#Forma-de-evaluación","page":"Generalidades","title":"Forma de evaluación","text":"","category":"section"},{"location":"","page":"Generalidades","title":"Generalidades","text":"La evaluación consta de la entrega semanal de una lista de ejercicios y de un trabajo final del curso. Por un lado, se requiere tener aprobado el 70% del total de los ejercicios propuestos. Por otro lado, se debe aprobar el trabajo final, que se enfoca al desarrollo de un paquete de Julia para la resolución de un problema de computación científica de interés para el/la estudiante. El/la estudiante defenderá un anteproyecto en un plazo límite establecido al inicio del curso. Finalmente, el proyecto completo, acompañado del código fuente y la documentación correspondiente, se defenderá en una exposición oral abierta a otros estudiantes del curso con preguntas de los docentes.","category":"page"},{"location":"#Temario","page":"Generalidades","title":"Temario","text":"","category":"section"},{"location":"","page":"Generalidades","title":"Generalidades","text":"Herramientas básicas. Alcance de la computación científica. Revisión de lenguajes de alto nivel vs. lenguajes de programación de sistemas. Revisión de aritmética de punto flotante. Conceptos básicos de Julia. Entorno de desarrollo. Herramienta git para control de revisión. Conceptos de desarrollo open source. Patrones de diseño de software en la computación científica.","category":"page"},{"location":"","page":"Generalidades","title":"Generalidades","text":"Fundamentos de Julia. Tipos de datos básicos. Variables. Arreglos. Módulos. Gestor de paquetes. Estructuras de datos. Gráficos en 2D y 3D. Lectura y escritura de archivos. Tipos concretos y abstractos. Tipos paramétricos. Despacho múltiple (multiple dispatch). Diseño de funciones. Evaluación en el sitio (in-place). Evaluación perezosa (lazy). Interfaces. Macros. Metaprogramación y ejemplos de lenguajes específicos de dominio (DSL).","category":"page"},{"location":"","page":"Generalidades","title":"Generalidades","text":"Patrones de diseño. Generación de paquetes. Patrones para reutilización de código. Generación de tests. Documentación de código. Integración continua. Patrones para código de alto desempeño (performance). Análisis de desempeño (profiling). Depuración de código. Patrones de robustez. Programación genérica. Programación paralela. Anti-patrones.","category":"page"},{"location":"","page":"Generalidades","title":"Generalidades","text":"Ecosistema de Julia para computación científica. Conceptos avanzados de gráficos y generación de gráficos para publicaciones. Paquetes para trabajar con datos, como data frames, y aprendizaje estadístico. Paquetes para resolver sistemas dinámicos, e.g. ecuaciones diferenciales ordinarias y ecuaciones en derivadas parciales. Paquetes para modelado y resolución de problemas de optimización matemática. Nota: los contenidos de esta parte son indicativos y se contempla adaptarlos a los intereses de los/las estudiantes.","category":"page"},{"location":"#Cronograma","page":"Generalidades","title":"Cronograma","text":"","category":"section"},{"location":"","page":"Generalidades","title":"Generalidades","text":"Semana Clases Temas Fecha entregable\n1 02/08 05/08 Alcance del curso. Entorno de desarrollo. 08/08\n2 09/08 12/08 Primeros pasos en Julia. 15/08\n3 16/08 19/08 Computación numérica. Computación simbólica. 24/08\n4 23/08 26/08 Fundamentos de Julia. Tipos de datos básicos. Reglas de alcance. Arreglos. 02/09\n5 30/08 02/09 Gestor de paquetes. Estructuras de datos. Funciones. 09/09\n6 06/09 09/09 Mecanismos de evaluación. Metaprogramación. -\n7 20/09 23/09 Patrones de diseño. Generación de paquetes. Patrones para reutilización de código. Patrones para performance. 25/06\n8 27/09 30/09 Programación genérica. Anti-patrones. Librerías. Propuestas de proyecto. 03/10\nX 04/10 07/10 X -\n9 11/10 14/10 Patrones de robustez. Optimización. Modelado y simulaciones numéricas. -\n10 18/10 21/10 Aprendizaje automático. Programación paralela. Gráficos para publicaciones. Última clase: 21/10\n11 25/10 28/10 Cierre ejemplo Predation. Proyecto. Última clase: 25/10\n12 01/11 04/11 Proyecto. -\n13 07/11 11/11 Proyecto. -\n14 14/11 18/11 Proyecto. -\n15 21/11 25/11 Proyecto. Defensa del proyecto: 25/11 en FING","category":"page"},{"location":"","page":"Generalidades","title":"Generalidades","text":"Notas:","category":"page"},{"location":"","page":"Generalidades","title":"Generalidades","text":"La columna de semana se refiere al numero de semanas transcurridas respecto delinicio del curso.\nEl cronograma es tentativo y lo iremos actualizando con el correr del curso.","category":"page"},{"location":"#Horarios","page":"Generalidades","title":"Horarios","text":"","category":"section"},{"location":"","page":"Generalidades","title":"Generalidades","text":"Horarios del curso 2023 (1er semestre)","category":"page"},{"location":"","page":"Generalidades","title":"Generalidades","text":"18:30 a 20 teóricos jueves\n18:30 a 20 teóricos viernes\n20 a 21:30 práctico viernes","category":"page"},{"location":"#Bibliografía","page":"Generalidades","title":"Bibliografía","text":"","category":"section"},{"location":"","page":"Generalidades","title":"Generalidades","text":"A continuación se lista la bibliografía principal. Por otro lado, cada sección incluye referencias específicas ya sea a textos, a páginas web o a paquetes de Julia.","category":"page"},{"location":"","page":"Generalidades","title":"Generalidades","text":"Hands-On Design Patterns and Best Practices with Julia: Proven solutions to common problems in software design for Julia 1. x. Kwong, T.  Packt Publishing Ltd, 2020.  ISBN: 9781838648817\nFundamentals of Numerical Computation (Vol. 154). Driscoll, T. A., & Braun, R. J. SIAM 2017.  ISBN: 9781611975079\nAlgorithms for Optimization. Kochenderfer, M and Wheeler, T. A.  2019. ISBN: 9780262039420\nPro git. Chacon, S. and Straub, B. Springer Nature, 2014.  ISBN: 9781430218333\nPrinciples of scientific computing. Bindel, D. and Goodman, J. New York University, 2009.\nStatistics with Julia. Nazarathy, Yoni, and Hayden Klok. 2021. 2365-5682\nNumerical Linear Algebra with Julia. Darve E, Wootters M. SIAM; 2021. Darve E, Wootters M. ISBN: 9781611976540","category":"page"},{"location":"Ecosistema/intro/","page":"-","title":"-","text":"# Librerías","category":"page"},{"location":"Ecosistema/intro/","page":"-","title":"-","text":"En esta parte exploraremos ciertas librerías o ecosistemas de interés para la computación científica en Julia.","category":"page"},{"location":"Fundamentos/Mecanismos de evaluacion/#Mecanismos-de-evaluacion","page":"Mecanismos de evaluacion","title":"Mecanismos de evaluacion","text":"","category":"section"},{"location":"Fundamentos/Mecanismos de evaluacion/#Evaluacion-en-el-sitio","page":"Mecanismos de evaluacion","title":"Evaluacion en el sitio","text":"","category":"section"},{"location":"Fundamentos/Mecanismos de evaluacion/#Evaluación-perezosa","page":"Mecanismos de evaluacion","title":"Evaluación perezosa","text":"","category":"section"},{"location":"Patrones/reutilizacion/#Patrones-para-reutilizacion-de-codigo","page":"Patrones para reutilización de código","title":"Patrones para reutilizacion de codigo","text":"","category":"section"},{"location":"Patrones/reutilizacion/#Interfaces","page":"Patrones para reutilización de código","title":"Interfaces","text":"","category":"section"},{"location":"Patrones/reutilizacion/#Manejo-de-archivos","page":"Patrones para reutilización de código","title":"Manejo de archivos","text":"","category":"section"},{"location":"Herramientas/Computacion_simbolica/#Computación-simbólica","page":"Computación simbólica","title":"Computación simbólica","text":"","category":"section"},{"location":"Herramientas/Computacion_simbolica/#Expresiones-simbólicas","page":"Computación simbólica","title":"Expresiones simbólicas","text":"","category":"section"},{"location":"Herramientas/Computacion_simbolica/#Iteradores","page":"Computación simbólica","title":"Iteradores","text":"","category":"section"},{"location":"Herramientas/Computacion_simbolica/#Diferenciación-automática","page":"Computación simbólica","title":"Diferenciación automática","text":"","category":"section"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":"Las técnicas de diferenciación automática (AD) son algoritmos para evaluar numéricamente las derivadas de funciones especificadas por un programa computacional. La AD explota el hecho de que, independientemente de su complejidad, todo programa computacional ejecuta una secuencia de opraciones matemáticas elementales (suma, resta, multiplicación, división, etc.) y funciones elementales (exp, log, sin, cos, etc.). La AD aplica repetidamente la regla de la cadena para calcular, de forma automática, la derivada, de cualquier orden, de estas operaciones y funciones elementales.","category":"page"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":"La AD es diferente a la diferenciación simbólica y a la diferenciación numérica. La diferenciación simbólica consiste en transformar el programa computacional en una expresión matemática. La diferenciación numérica, como ser diferencias finitas, requiere de una discretización, que conlleva un error de truncamiento y de cancelación. Además, estos dos últimos pueden ser ineficientes cuando el número de inputs es alto, y requiere de la aplicación de algoritmos de optimización basados en el gradiente.","category":"page"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":"La AD se basa en la regla de la cadena:","category":"page"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":"\ndfracddx f(g(x)) = dfracddx (f circ g) = dfracdfdgdfracdgdx\n\n\nConsideremos la función f(ab) = ln(ab+max(a 2))","category":"page"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":".","category":"page"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":"La derivada de f respecto de a resulta:","category":"page"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":"dfracpartial fpartial a = dfrac1ab+max(a 2)b + (2a)","category":"page"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":".","category":"page"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":"El proceso detrás de este cálculo se puede automatizar por medio de un grafo computacional. Estos grafos representan una funcion donde los nodos son operaciones y las aristas son relaciones input-output. Las hojas del grafo son las variables input y las constantes involucradas, mientras que los nodos terminales son los otuput de la función.","category":"page"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":"(Image: Grafo computacional)","category":"page"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":"Existen dos métodos para derivar f automáticamente usando su grafo computacional: la acumulación hacia adelante, que atraviesa el grafo en la dirección inputstooutputs usando números duales, y la acumlación reversa, que requiere de una recorrida del grafo hacia atrás.","category":"page"},{"location":"Herramientas/Computacion_simbolica/#Acumulación-hacia-adelante-(*Forward-accumulation*)","page":"Computación simbólica","title":"Acumulación hacia adelante (Forward accumulation)","text":"","category":"section"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":"Este método usa una única pasada del grafo computacional y es equivalente a expandir iterativamente la regla de la cadena de las operaciones internas. Cuando f depende de varias variables, se debe hacer una recorrida del grafo por cada derivada parcial. Por ejemplo:","category":"page"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":"dfracdfda = dfracdfd c_4  dfracd c_4 da=dfracdfdc_4left(dfracdc_4dc_3dfracdc_3daright) = dfracdfdc_4left(dfracdc_4dc_3left(dfracdc_3dc_2dfracdc_2da+dfracdc_3dc_1dfracdc_1daright)right)","category":"page"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":"En color azul se representan las evaluaciones de las variables sucesivas, mientras en color rojo las derivadas respecto de a. El procedimiento es el siguiente:","category":"page"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":"Comenzamos desde los nodos de inputs y de valores constantes. Allí calculamos su valor y el valor de la derivada respecto de a. Por ejemplo, para a=3, b=2, este paso sería:","category":"page"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":"(Image: Grafo computacional: Forward accumulation)","category":"page"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":"Luego, procedemos a recorrer el árbol, nodo por nodo, calculando el valor de la variable en el nodo y de la derivada. Para ello, debemos escoger el nodo a recorrer en cada paso de manera que ya conozcamos o hayamos calculado los inputs. Así obtenemos el siguiente grafo:","category":"page"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":"(Image: Grafo computacional: Forward accumulation)","category":"page"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":"Este cálculo puede ser automatizado en una computadora si utilizamos los \"números duales\", que permiten calcular a la vez el valor de la función y de su derivada en cada nodo con una sola operación. Los números duales se escriben de manera similar a los complejos, a+b epsilon, pero tal que epsilon^2=0. Por lo tanto:","category":"page"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":"(a+b epsilon) + (c+d epsilon) = (a+c)+ (b+d) epsilon","category":"page"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":"(a+b epsilon) times (c+d epsilon) = (ab)+ (ad+bc)epsilon","category":"page"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":"Si escribimos la expansión de Taylor de f(x) en torno a a, f(x)=displaystyle sum_k=0^inftydfracf^(k)(a)k(x-a)^k, se obtiene que:","category":"page"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":"f(a+bepsilon)=f(a)+b f^prime(a)epsilon","category":"page"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":"Por lo tanto, si pasamos un número dual a f, obtenemos f y f^prime en una sola evaluación.","category":"page"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":"Con este procedimiento, para calcular el gradiente de una función que depende de n variables, debemos recorrer n veces el grafo. Por esto, la acumulación hacia adelante es recomendada cuando el número de outputs es mucho mayor que el número de inputs.","category":"page"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":"Ejemplo: f(x_1x_2)=x_1 x_2 + sin x_1","category":"page"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":"(Image: Grafo computacional: Forward accumulation (Wiki))","category":"page"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":"Implementación en Julia de la diferenciación automática de f(ab) = ln(ab+max(a 2)) para a=3, b=2 con el método de acumulación hacia adelante:","category":"page"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":"1- Definimos el struct para representar los números duales","category":"page"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":"struct Dual\n\tv\n\t∂\nend\n\nBase.:+(a::Dual, b::Dual) = Dual(a.v + b.v, a.∂ + b.∂)\n\nBase.:*(a::Dual, b::Dual) = Dual(a.v * b.v, a.v*b.∂ + b.v*a.∂)\n\nBase.log(a::Dual) = Dual(log(a.v), a.∂/a.v)\n\nfunction Base.max(a::Dual, b::Dual)\n\tv = max(a.v, b.v)\n\t∂ = a.v > b.v ? a.∂ : a.v < b.v ? b.∂ : NaN\n\treturn Dual(v, ∂)\nend\n\nfunction Base.max(a::Dual, b::Int)\n\tv = max(a.v, b)\n\t∂ = a.v > b ? a.∂ : a.v < b ? 0 : NaN\n\treturn Dual(v, ∂)\nend","category":"page"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":"2- Computamos el gradiente en a=3, b=2 con el paquete ForwardDiff.jl:","category":"page"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":"using ForwardDiff\n\na = ForwardDiff.Dual(3,1);\nb = ForwardDiff.Dual(2,0);\n\nlog(a*b + max(a,2)) # Forward Differentitaion","category":"page"},{"location":"Herramientas/Computacion_simbolica/#Acumulación-reversa-(*Reverse-accumulation*)","page":"Computación simbólica","title":"Acumulación reversa (Reverse accumulation)","text":"","category":"section"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":"La acumulación reversa requiere de una sola corrida para calcular el gradiente de f, independientemente de la cantidad de variables de las que depende, pero requiere de dos recorridas del grafo: una pasada hacia adelante (forward pass), en la que se computan todos los valores intermedios necesarios, y otra pasada hacia atrás (backward pass), que es la que computa el gradiente.","category":"page"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":"El procedimiento consiste en explotar la relación:","category":"page"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":"displaystyle barc_i = dfracpartial fpartial c_i = sum_j  j mathrm  es  hijo  de   i barc_j dfracpartial c_jpartial c_i","category":"page"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":",","category":"page"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":"donde barc_i es el \"adjunto\" de c_i. Para derivar f respecto de a, se sigue el grafo desde el final hasta el principio, aplicando esta relación recursiva.","category":"page"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":"En el caso de la acumulación reversa, solo se debe hacer una corrida hacia adelante (en comparación con las n corridas necesarias en la acumulación hacia adelante para computar un gradiente en dimensión n), pero se deben tener todas las en memoria la relación entre cada variable intermedia y su derivada respecto de los nodos \"hijos\" en el grafo, que fueron calculadas en el paso hacia adelante. Si el grafo es grande (número de inputs mucho mayor que de outputs), el requerimiento de memoria puede ser excesivo.","category":"page"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":"Ejemplo:","category":"page"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":"(Image: Grafo computacional: Reverse accumulation)","category":"page"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":"Ejemplo: f(x_1x_2)=x_1 x_2 + sin x_1","category":"page"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":"(Image: Grafo computacional: Reverse accumulation (Wiki))","category":"page"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":"Implementación en Julia de la diferenciación automática de f(ab) = ln(ab+max(a 2)) para a=3, b=2 con el método de acumulación reversa:","category":"page"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":"using Zygote: gradient\n\nf(a, b) = log(a*b + max(a,2))\n\ngradient(f, 3.0, 2.0) # Reverse Accumulation","category":"page"},{"location":"Herramientas/Computacion_simbolica/#Link-recomendado:","page":"Computación simbólica","title":"Link recomendado:","text":"","category":"section"},{"location":"Herramientas/Computacion_simbolica/","page":"Computación simbólica","title":"Computación simbólica","text":"\"What is Automatic Differentiation?\"","category":"page"},{"location":"Herramientas/Alcance_del_curso/#Alcance-del-curso","page":"Alcance del curso","title":"Alcance del curso","text":"","category":"section"},{"location":"Herramientas/Alcance_del_curso/#Características-de-la-computación-científica","page":"Alcance del curso","title":"Características de la computación científica","text":"","category":"section"},{"location":"Herramientas/Alcance_del_curso/#Lenguajes-de-\"bajo\"-y-de-\"alto\"-nivel","page":"Alcance del curso","title":"Lenguajes de \"bajo\" y de \"alto\" nivel","text":"","category":"section"},{"location":"Herramientas/Alcance_del_curso/#Ejemplos","page":"Alcance del curso","title":"Ejemplos","text":"","category":"section"},{"location":"Herramientas/Alcance_del_curso/#El-paradigma-de-código-abierto","page":"Alcance del curso","title":"El paradigma de código abierto","text":"","category":"section"},{"location":"Herramientas/Alcance_del_curso/#Panorama-del-curso","page":"Alcance del curso","title":"Panorama del curso","text":"","category":"section"},{"location":"Entregables/Entregable5/","page":"Entregable 5","title":"Entregable 5","text":"warning: Entrega\nSe debe entregar un archivo .ZIP llamado Entregable_5 que contenga un archivo de Julia (.jl) por cada ejercicio Ejercicio1.jl, Ejercicio2.jl, etc. Deben entregar solamente una parte. Fecha límite de entrega: 9 de mayo.","category":"page"},{"location":"Entregables/Entregable5/#Parte-A.","page":"Entregable 5","title":"Parte A.","text":"","category":"section"},{"location":"Entregables/Entregable5/#.-Aritmética-básica-y-asignación-de-variables","page":"Entregable 5","title":"1. Aritmética básica y asignación de variables","text":"","category":"section"},{"location":"Entregables/Entregable5/","page":"Entregable 5","title":"Entregable 5","text":"En este ejercicio, realizarás operaciones aritméticas básicas y asignarás los resultados a variables.","category":"page"},{"location":"Entregables/Entregable5/","page":"Entregable 5","title":"Entregable 5","text":"Asigna el valor de 7 a una variable llamada x.\nAsigna el valor de 5 a una variable llamada y.\nCalcula la suma, diferencia, producto y cociente de x e y, y asigna los resultados a las variables suma_xy, dif_xy, prod_xy y cociente_xy, respectivamente.\nImprime los valores de estas variables.","category":"page"},{"location":"Entregables/Entregable5/","page":"Entregable 5","title":"Entregable 5","text":"Salida esperada:","category":"page"},{"location":"Entregables/Entregable5/","page":"Entregable 5","title":"Entregable 5","text":"12\n2\n35\n1.4","category":"page"},{"location":"Entregables/Entregable5/#.-Intercambiar-variables","page":"Entregable 5","title":"2. Intercambiar variables","text":"","category":"section"},{"location":"Entregables/Entregable5/","page":"Entregable 5","title":"Entregable 5","text":"En este ejercicio, intercambiarás los valores de dos variables sin usar una tercera variable.","category":"page"},{"location":"Entregables/Entregable5/","page":"Entregable 5","title":"Entregable 5","text":"Utiliza las mismas variables x e y que asignaste en el Ejercicio 1.\nIntercambia los valores de x e y usando operaciones aritméticas.\nImprime los nuevos valores de x e y.","category":"page"},{"location":"Entregables/Entregable5/","page":"Entregable 5","title":"Entregable 5","text":"Salida esperada:","category":"page"},{"location":"Entregables/Entregable5/","page":"Entregable 5","title":"Entregable 5","text":"5\n7","category":"page"},{"location":"Entregables/Entregable5/#.-Conversión-de-Celsius-a-Fahrenheit","page":"Entregable 5","title":"3. Conversión de Celsius a Fahrenheit","text":"","category":"section"},{"location":"Entregables/Entregable5/","page":"Entregable 5","title":"Entregable 5","text":"En este ejercicio, convertirás un valor de temperatura en grados Celsius a grados Fahrenheit.","category":"page"},{"location":"Entregables/Entregable5/","page":"Entregable 5","title":"Entregable 5","text":"Asigna el valor de 100 a una variable llamada celsius.\nCalcula el valor Fahrenheit correspondiente y asígnalo a una variable llamada fahrenheit.\nImprime el valor Fahrenheit.","category":"page"},{"location":"Entregables/Entregable5/","page":"Entregable 5","title":"Entregable 5","text":"Salida esperada:","category":"page"},{"location":"Entregables/Entregable5/","page":"Entregable 5","title":"Entregable 5","text":"212.0","category":"page"},{"location":"Entregables/Entregable5/#.-Resolución-de-una-ecuación-cuadrática","page":"Entregable 5","title":"4. Resolución de una ecuación cuadrática","text":"","category":"section"},{"location":"Entregables/Entregable5/","page":"Entregable 5","title":"Entregable 5","text":"En este ejercicio, resolverás una ecuación cuadrática de la forma ax^2 + bx + c = 0, donde a, b y c son constantes.","category":"page"},{"location":"Entregables/Entregable5/","page":"Entregable 5","title":"Entregable 5","text":"Asigna los valores de 1, -3 y 2 a las variables a, b y c, respectivamente.\nCalcula el discriminante y asigna el resultado a una variable llamada discriminante.\nCalcula las dos soluciones de la ecuación cuadrática usando la fórmula general y asigna los resultados a las variables x1 y x2.\nImprime las soluciones.","category":"page"},{"location":"Entregables/Entregable5/","page":"Entregable 5","title":"Entregable 5","text":"Salida esperada:","category":"page"},{"location":"Entregables/Entregable5/","page":"Entregable 5","title":"Entregable 5","text":"2.0\n1.0","category":"page"},{"location":"Entregables/Entregable5/#.-Cálculo-de-interés-compuesto","page":"Entregable 5","title":"5. Cálculo de interés compuesto","text":"","category":"section"},{"location":"Entregables/Entregable5/","page":"Entregable 5","title":"Entregable 5","text":"En este ejercicio, calcularás el valor futuro de una inversión utilizando interés compuesto.","category":"page"},{"location":"Entregables/Entregable5/","page":"Entregable 5","title":"Entregable 5","text":"Asigna el monto principal de 1000 a una variable llamada principal.\nAsigna la tasa de interés anual del 5% (0.05) a una variable llamada tasa_interes.\nAsigna el número de años (10) a una variable llamada años.\nAsigna el número de veces que se compone el interés por año (12) a una variable llamada compuestos_por_año.\nCalcula el valor futuro de la inversión utilizando la fórmula de interés compuesto y asigna el resultado a una variable llamada valor_futuro.\nImprime el valor futuro.","category":"page"},{"location":"Entregables/Entregable5/","page":"Entregable 5","title":"Entregable 5","text":"Salida esperada:","category":"page"},{"location":"Entregables/Entregable5/","page":"Entregable 5","title":"Entregable 5","text":"1647.0094976907984","category":"page"},{"location":"Entregables/Entregable5/#Parte-B.","page":"Entregable 5","title":"Parte B.","text":"","category":"section"},{"location":"Entregables/Entregable5/#.-Conversion-a-escala-de-grises","page":"Entregable 5","title":"1. Conversion a escala de grises","text":"","category":"section"},{"location":"Entregables/Entregable5/","page":"Entregable 5","title":"Entregable 5","text":"Escribir una función que es capaz de recibir una imagen de entrada y convertirla a escala de grises.","category":"page"},{"location":"Entregables/Entregable5/","page":"Entregable 5","title":"Entregable 5","text":"Sugerencia 1: utilizar la biblioteca Images de Julia para leer la imagen en formato PNG. Ver Entregable 4 que contiene código de ejemplo.","category":"page"},{"location":"Entregables/Entregable5/","page":"Entregable 5","title":"Entregable 5","text":"Sugerencia 2: Utilizar la función Gray.(img) para convertir la imagen a escala de grises si está en formato RGB u otro formato.","category":"page"},{"location":"Entregables/Entregable5/#.-Cálculo-de-gradientes","page":"Entregable 5","title":"2. Cálculo de gradientes","text":"","category":"section"},{"location":"Entregables/Entregable5/","page":"Entregable 5","title":"Entregable 5","text":"Definir una función imgradients que calcula los gradientes de una imagen en escala de grises en ambas direcciones, horizontal (dx) y vertical (dy).","category":"page"},{"location":"Entregables/Entregable5/","page":"Entregable 5","title":"Entregable 5","text":"Puede ya sea escribir su propio algoritmo, o seguir el siguiente pseudo-código, que provee una implementación simple que calcula los gradientes utilizando un método básico de diferencias finitas.","category":"page"},{"location":"Entregables/Entregable5/","page":"Entregable 5","title":"Entregable 5","text":"Definir una función imgradients(img) que tome como entrada una matriz de imagen en escala de grises 2D.\nInicializar dos matrices del mismo tamaño que la imagen de entrada, dx y dy, para almacenar los gradientes horizontales y verticales.\nIterar sobre los píxeles de la imagen de entrada, excluyendo los píxeles del borde (comenzar desde la segunda fila y columna y terminar en la penúltima fila y columna): a. Para cada píxel (x, y), calcular el gradiente horizontal dx[y, x] como la diferencia entre la intensidad del píxel a la derecha y el píxel a la izquierda, dividida por 2: (img[y, x + 1] - img[y, x - 1]) / 2. b. Para cada píxel (x, y), calcular el gradiente vertical dy[y, x] como la diferencia entre la intensidad del píxel debajo y el píxel arriba, dividida por 2: (img[y + 1, x] - img[y - 1, x]) / 2.\nDevolver las matrices de gradientes horizontales y verticales dx y dy.","category":"page"},{"location":"Entregables/Entregable5/#.-Detección-de-puntos-con-el-método-de-Harris","page":"Entregable 5","title":"3. Detección de puntos con el método de Harris","text":"","category":"section"},{"location":"Entregables/Entregable5/","page":"Entregable 5","title":"Entregable 5","text":"En el procesamiento digital de imágenes, una esquina es un punto de interés donde la intensidad de los píxeles varía significativamente en múltiples direcciones. El algoritmo de detección de esquinas de Harris es un método popular para detectar esquinas en imágenes. Funciona analizando la estructura local de la imagen e identificando regiones donde el cambio en la intensidad es significativo a lo largo de diferentes ejes. El algoritmo es particularmente útil en aplicaciones de visión por computadora, como detección de características, unión de imágenes y reconocimiento de objetos.","category":"page"},{"location":"Entregables/Entregable5/","page":"Entregable 5","title":"Entregable 5","text":"Se sugiere seguir el siguiente pseudocódigo de alto nivel para la implementación del algoritmo de detección de esquinas de Harris:","category":"page"},{"location":"Entregables/Entregable5/","page":"Entregable 5","title":"Entregable 5","text":"Cargar la imagen de entrada y convertirla a escala de grises.\nCalcular los gradientes de la imagen en escala de grises en ambas direcciones, horizontal (dx) y vertical (dy).\nCalcular los productos de los gradientes (Ix2, Iy2 e Ixy) en cada píxel.\nPara cada píxel (x, y) en la imagen: a. Inicializar una matriz M de 2x2 en ceros. b. Iterar a través de una ventana (vecindario) centrada en el píxel (x, y):    i. Acumular los productos de los gradientes (Ix2, Iy2 e Ixy) dentro de la ventana en la matriz M. c. Calcular la respuesta de esquina R para el píxel (x, y) usando el determinante y la traza de la matriz M: R = det(M) - k * (tr(M) ^ 2), donde k es un factor de sensibilidad (típicamente 0.04-0.06). d. Si R es mayor que un umbral predefinido, marcar el píxel (x, y) como una esquina.\nExtraer las coordenadas de las esquinas detectadas y devolverlas como una lista de puntos.","category":"page"},{"location":"Entregables/Entregable5/","page":"Entregable 5","title":"Entregable 5","text":"Este pseudocódigo  describe los pasos principales del algoritmo de detección de esquinas de Harris, desde cargar la imagen de entrada hasta extraer las coordenadas de las esquinas detectadas. Esta es una implementación básica y se pueden aplicar optimizaciones de rendimiento para mejorar la eficiencia del algoritmo en la práctica.","category":"page"},{"location":"Entregables/Entregable5/","page":"Entregable 5","title":"Entregable 5","text":"A continuación se proveen algunas sugerencias para los pasos del pseudo-código:","category":"page"},{"location":"Entregables/Entregable5/","page":"Entregable 5","title":"Entregable 5","text":"Cargar la imagen de entrada y convertirla a escala de grises. Ver Ejercicio 1.\nCalcular los gradientes de la imagen en escala de grises en ambas direcciones, horizontal (dx) y vertical (dy). Ver Ejercicio 2.\nCalcular los productos de los gradientes (Ix2, Iy2 e Ixy) en cada píxel.\nPista 1: Calcular Ix2 como el producto de dx * dx, Iy2 como el producto de dy * dy, e Ixy como el producto de dx * dy.\nPista 2: Utilizar operaciones de matriz (elemento por elemento) para un cálculo eficiente.\nPara cada píxel (x, y) en la imagen: (...)\nPista 1: Utilizar bucles anidados for para iterar sobre todos los píxeles de la imagen, excluyendo los bordes si es necesario.\nPista 2: Inicializar la matriz M en ceros y acumular los productos de gradientes dentro de la ventana utilizando bucles adicionales for.\nExtraer las coordenadas de las esquinas detectadas y devolverlas como una lista de puntos.\nPista 1: Utilizar la función findall(corners .> threshold) para obtener las coordenadas de los píxeles con valores de respuesta de esquina mayores que el umbral.\nPista 2: Convertir las coordenadas obtenidas en una lista de puntos (tuplas) utilizando la función map de Julia.","category":"page"},{"location":"Entregables/Entregable5/","page":"Entregable 5","title":"Entregable 5","text":"","category":"page"},{"location":"Entregables/Entregable5/","page":"Entregable 5","title":"Entregable 5","text":"Nota: Partes de este entregable fueron desarrolladas con la asistencia de OpenAI's ChatGPT, un modelo de lenguaje natural de gran escala. Ver Radford, A., Narasimhan, K., Salimans, T., & Sutskever, I. (2018). Improving Language Understanding by Generative Pre-Training.\"","category":"page"},{"location":"Entregables/Entregable6/#Entregable-6","page":"Entregable 6","title":"Entregable 6","text":"","category":"section"},{"location":"Entregables/Entregable6/","page":"Entregable 6","title":"Entregable 6","text":"warning: Entrega\nSe debe entregar un archivo .ZIP llamado Entregable_6 que contenga un archivo de Julia (.jl) por cada ejercicio Ejercicio1.jl, Ejercicio2.jl, etc. Deben entregar solamente una parte. Fecha límite de entrega: Viernes 12 de mayo.","category":"page"},{"location":"Entregables/Entregable6/#Parte-A.","page":"Entregable 6","title":"Parte A.","text":"","category":"section"},{"location":"Entregables/Entregable6/#Parte-B.","page":"Entregable 6","title":"Parte B.","text":"","category":"section"},{"location":"Entregables/Entregable6/#.-Torre-de-Hanoi.","page":"Entregable 6","title":"1. Torre de Hanoi.","text":"","category":"section"},{"location":"Entregables/Entregable6/","page":"Entregable 6","title":"Entregable 6","text":"Implementar la funcion solve para el juego de Hanoi que se encuentra en los notebooks de ejemplo de Pluto.jl.","category":"page"},{"location":"Entregables/otros/#Puntos","page":"-","title":"Puntos","text":"","category":"section"},{"location":"Entregables/otros/","page":"-","title":"-","text":"Realizar un demostración que ilustre de forma gráfica el siguiente enunciado:","category":"page"},{"location":"Entregables/otros/","page":"-","title":"-","text":"Si se colocan 5 puntos en un cuadrado de lado 1, entonces siempre se cumple que existe por lo menos un par de puntos que están separados a lo sumo una distancia de 3/4.","category":"page"},{"location":"Entregables/otros/","page":"-","title":"-","text":"Sugerencia: utilizar los paquetes LazySets.jl y Plots.jl para representar y graficar figuras geométricas respectivamente. ","category":"page"},{"location":"Entregables/Entregable2/#Entregable-2","page":"Entregable 2","title":"Entregable 2","text":"","category":"section"},{"location":"Entregables/Entregable2/","page":"Entregable 2","title":"Entregable 2","text":"warning: Entrega\nSe debe entregar un archivo .ZIP llamado Entregable_2 que contenga un archivo de Julia (.jl) por cada ejercicio Ejercicio1.jl, Ejercicio2.jl, etc. Fecha límite de entrega: Viernes 31 de marzo.","category":"page"},{"location":"Entregables/Entregable2/#.","page":"Entregable 2","title":"1.","text":"","category":"section"},{"location":"Entregables/Entregable2/","page":"Entregable 2","title":"Entregable 2","text":"a) Crear dos matrices aleatorias A y B de tamaño 3x3 con números enteros del 1 al 10. La distribución debe ser uniforme. Luego sumarlas para producir una matriz C.","category":"page"},{"location":"Entregables/Entregable2/","page":"Entregable 2","title":"Entregable 2","text":"b) Crear dos matrices aleatorias D y E de tamaño 3x2 y 2x3 respectivamente, con números de punto flotante del 1 al 10. Efectuar muestreo por descarte (rejection sampling) de una distribución normal de media 0 y varianza 1. Luego multiplicarlas para producir una matriz F.","category":"page"},{"location":"Entregables/Entregable2/","page":"Entregable 2","title":"Entregable 2","text":"c) Crear una matriz aleatoria G con de tamaño 3x4 con números de punto flotante del 1 al 10. Para el muestreo usar la misma tecnica que en el parte anterior, pero con una normal de media 5 y varianza 1. Calcular su matriz traspuesta H utilizando la función transpose de Julia.","category":"page"},{"location":"Entregables/Entregable2/#.-2","page":"Entregable 2","title":"2.","text":"","category":"section"},{"location":"Entregables/Entregable2/","page":"Entregable 2","title":"Entregable 2","text":"Escribir su propia funcion transponer(A::Matrix{Int64}) que recibe una mariz de números enteros y devuelve la matriz transpuesta. Corroborar con el resultado obtenido en la parte 1c.","category":"page"},{"location":"Entregables/Entregable2/#.-3","page":"Entregable 2","title":"3.","text":"","category":"section"},{"location":"Entregables/Entregable2/","page":"Entregable 2","title":"Entregable 2","text":"Se dan las coordenadas de los extremos (inferior izquierdo y superior derecho) de dos rectangulos en un plano.","category":"page"},{"location":"Entregables/Entregable2/","page":"Entregable 2","title":"Entregable 2","text":"Escribir una funcion area(a, b, c, d) tal que devuelve el area total cubierta por los dos rectangulos definidos por (a, b) y (c, d) respectivamente.","category":"page"},{"location":"Entregables/Entregable2/","page":"Entregable 2","title":"Entregable 2","text":"Por ejemplo,","category":"page"},{"location":"Entregables/Entregable2/","page":"Entregable 2","title":"Entregable 2","text":"julia> area((-3, 0), (3, 4), (0, -1), (9, 2))\n45","category":"page"},{"location":"Entregables/Entregable3/#Entregable-3","page":"Entregable 3","title":"Entregable 3","text":"","category":"section"},{"location":"Entregables/Entregable3/","page":"Entregable 3","title":"Entregable 3","text":"warning: Entrega\nSe debe entregar un archivo .ZIP llamado Entregable_3 que contenga un archivo de Julia (.jl) por cada ejercicio Ejercicio1.jl, Ejercicio2.jl, etc. Fecha límite de entrega: Viernes 14 de abril.","category":"page"},{"location":"Entregables/Entregable3/#.","page":"Entregable 3","title":"1.","text":"","category":"section"},{"location":"Entregables/Entregable3/","page":"Entregable 3","title":"Entregable 3","text":"La traza de una mariz cuadrada de define como la suma de sus elementos diagonales. Implementar una funcion traza que calcula la traza de una matriz.","category":"page"},{"location":"Entregables/Entregable3/#.-2","page":"Entregable 3","title":"2.","text":"","category":"section"},{"location":"Entregables/Entregable3/","page":"Entregable 3","title":"Entregable 3","text":"La norma matricial inducida por una p-norma (1 leq p leq infty) en vectores, para el caso p = 1, adquiere la forma:","category":"page"},{"location":"Entregables/Entregable3/","page":"Entregable 3","title":"Entregable 3","text":"Vert A Vert_1 = max_1 leq j leq n sum_i=1^n vert a_ij vert","category":"page"},{"location":"Entregables/Entregable3/","page":"Entregable 3","title":"Entregable 3","text":"Escribir una funcion norma1(A) que implementa la formula anterior.","category":"page"},{"location":"Entregables/Entregable3/","page":"Entregable 3","title":"Entregable 3","text":"Compara su resultado por el obtenido mediante la funcion norm de LinearAlgebra.","category":"page"},{"location":"Entregables/Entregable3/#.-3","page":"Entregable 3","title":"3.","text":"","category":"section"},{"location":"Entregables/Entregable3/","page":"Entregable 3","title":"Entregable 3","text":"Generalizar el método desarrollado en clase para obtener una cota inferior del área interior de un polígono convexo cualquiera.  Sugerencia: para representar dicho polígono, utilizar VPolygon de LazySets.","category":"page"},{"location":"Entregables/Entregable3/#.-4","page":"Entregable 3","title":"4.","text":"","category":"section"},{"location":"Entregables/Entregable3/","page":"Entregable 3","title":"Entregable 3","text":"Implementar un método para calcular el área de un polígono convexo que dé el resultado exacto.","category":"page"},{"location":"Entregables/Entregable3/","page":"Entregable 3","title":"Entregable 3","text":"Sugerencia: utilizar la fórmula del área de Gauss.","category":"page"},{"location":"Entregables/Entregable3/","page":"Entregable 3","title":"Entregable 3","text":"Comparar la estimación obtenida en el ejercicio 1 con el resultado exacto.","category":"page"},{"location":"Entregables/Entregable3/","page":"Entregable 3","title":"Entregable 3","text":"Suponiendo que las coordenadas del polígono son números racionales, ¿puede modificar su algoritmo para que el resultado del cálculo del área sea un número racional?","category":"page"},{"location":"Herramientas/Primeros_pasos_en_Julia/#Primeros-pasos-en-Julia","page":"Primeros pasos en Julia","title":"Primeros pasos en Julia","text":"","category":"section"},{"location":"Herramientas/Primeros_pasos_en_Julia/","page":"Primeros pasos en Julia","title":"Primeros pasos en Julia","text":"A continuación se da una pantallazo de distintos aspectos del lenguaje desde un punto de vista puramente práctico: mediante varios ejemplos de código se busca dar una visión de qué se trata el lenguaje. En otras partes del curso se profundizará en los distintos aspectos aquí mencionados.","category":"page"},{"location":"Herramientas/Primeros_pasos_en_Julia/#Variables","page":"Primeros pasos en Julia","title":"Variables","text":"","category":"section"},{"location":"Herramientas/Primeros_pasos_en_Julia/#Vectores","page":"Primeros pasos en Julia","title":"Vectores","text":"","category":"section"},{"location":"Herramientas/Primeros_pasos_en_Julia/#Matrices","page":"Primeros pasos en Julia","title":"Matrices","text":"","category":"section"},{"location":"Herramientas/Primeros_pasos_en_Julia/#Cadenas-de-caracteres","page":"Primeros pasos en Julia","title":"Cadenas de caracteres","text":"","category":"section"},{"location":"Herramientas/Primeros_pasos_en_Julia/#Diccionarios","page":"Primeros pasos en Julia","title":"Diccionarios","text":"","category":"section"},{"location":"Herramientas/Primeros_pasos_en_Julia/#Funciones","page":"Primeros pasos en Julia","title":"Funciones","text":"","category":"section"},{"location":"Herramientas/Primeros_pasos_en_Julia/#Control-de-flujo","page":"Primeros pasos en Julia","title":"Control de flujo","text":"","category":"section"},{"location":"Herramientas/Primeros_pasos_en_Julia/","page":"Primeros pasos en Julia","title":"Primeros pasos en Julia","text":"Como aplicación de los conceptos vistos anteriormente, consideramos la implementación de una de las funciones más básicas de ordenamiento: el método de ordenamiento de burbuja (bubblesort).","category":"page"},{"location":"Herramientas/Primeros_pasos_en_Julia/#Multiple-dispatch","page":"Primeros pasos en Julia","title":"Multiple dispatch","text":"","category":"section"},{"location":"Herramientas/Primeros_pasos_en_Julia/#Gestor-de-paquetes","page":"Primeros pasos en Julia","title":"Gestor de paquetes","text":"","category":"section"},{"location":"Herramientas/Primeros_pasos_en_Julia/#Gráficos","page":"Primeros pasos en Julia","title":"Gráficos","text":"","category":"section"},{"location":"Herramientas/Primeros_pasos_en_Julia/#Referencias","page":"Primeros pasos en Julia","title":"Referencias","text":"","category":"section"},{"location":"Herramientas/Primeros_pasos_en_Julia/","page":"Primeros pasos en Julia","title":"Primeros pasos en Julia","text":"The fast track to Julia\nGetting started with Julia / JuMP docs\njulia-mit Tutorial notebook\nIntroduction to Julia by Jose Storopoli (JuliaCon 2022)\nAn Introduction to Julia by Jane Herriman","category":"page"},{"location":"Herramientas/Primeros_pasos_en_Julia/","page":"Primeros pasos en Julia","title":"Primeros pasos en Julia","text":"","category":"page"},{"location":"Herramientas/Primeros_pasos_en_Julia/","page":"Primeros pasos en Julia","title":"Primeros pasos en Julia","text":"","category":"page"},{"location":"Herramientas/Primeros_pasos_en_Julia/#Entregable-2","page":"Primeros pasos en Julia","title":"Entregable 2","text":"","category":"section"},{"location":"Herramientas/Primeros_pasos_en_Julia/","page":"Primeros pasos en Julia","title":"Primeros pasos en Julia","text":"warning: Entrega\nSe debe entregar un archivo .ZIP llamado Entregable_2 que contenga un archivo de Julia (.jl) por cada ejercicio Ejercicio1.jl, Ejercicio2.jl, etc. Fecha límite de entrega: Jueves 30 de marzo.","category":"page"},{"location":"Herramientas/Primeros_pasos_en_Julia/#.1.","page":"Primeros pasos en Julia","title":"2.1.","text":"","category":"section"},{"location":"Herramientas/Primeros_pasos_en_Julia/#.2.","page":"Primeros pasos en Julia","title":"2.2.","text":"","category":"section"},{"location":"Fundamentos/Arreglos/#Arreglos","page":"Arreglos","title":"Arreglos","text":"","category":"section"},{"location":"Fundamentos/Arreglos/#Matrices-esparsas","page":"Arreglos","title":"Matrices esparsas","text":"","category":"section"},{"location":"Fundamentos/Arreglos/#Matrices-estáticas","page":"Arreglos","title":"Matrices estáticas","text":"","category":"section"},{"location":"Fundamentos/Arreglos/","page":"Arreglos","title":"Arreglos","text":"","category":"page"},{"location":"Fundamentos/Arreglos/#Entregable-6","page":"Arreglos","title":"Entregable 6","text":"","category":"section"},{"location":"Fundamentos/Arreglos/","page":"Arreglos","title":"Arreglos","text":"warning: Formato de entrega\nEl formato de entrega es análogo al utilizado en los entregables anteriores, ver Ejercicio 1.2 Creación de un repositorio. En particular, todos los ejercicios entregados deben ser parte de un único módulo llamado Entregable_6 que define la constante CI asi como también exporta las funciones que se piden en cada ejercicio entregado. Importante: Además debe incluir los archivos de proyecto (Project.toml y Manifest.toml) en su entrega. ","category":"page"},{"location":"Fundamentos/Arreglos/#.1.-Dibujo-de-grafos-con-el-método-del-equilibrio","page":"Arreglos","title":"6.1. Dibujo de grafos con el método del equilibrio","text":"","category":"section"},{"location":"Fundamentos/Arreglos/","page":"Arreglos","title":"Arreglos","text":"Existen diversas técnicas para dibujar grafos de manera automática, es decir, dado un grafo G = (V E) donde V es el conjunto de vértices y E es el conjunto de aristas, determinar posiciones (x_i y_i) para cada i = 1 ldots V de forma que el dibujo resultante muestre la simetría subyacente en el grafo. Entre ellas encontramos métodos basado en resortes (force-directed algorithms), que tienen las siguientes características generales:","category":"page"},{"location":"Fundamentos/Arreglos/","page":"Arreglos","title":"Arreglos","text":"Cada nodo se asocia con un masa puntual.\nCada arista se asocia con un resorte.","category":"page"},{"location":"Fundamentos/Arreglos/","page":"Arreglos","title":"Arreglos","text":"Mediante la asociación de las componentes del grafo con un sistema físico, se establece la posición final de los nodos como aquella que minimiza la energía total del sistema.","category":"page"},{"location":"Fundamentos/Arreglos/","page":"Arreglos","title":"Arreglos","text":"En este ejercicio se deberá implementar el algoritmo que se describe en el artículo de Kamada, Tomihisa, and Satoru Kawai, \"An algorithm for drawing general undirected graphs.\" Information processing letters 31.1 (1989): 7-15.","category":"page"},{"location":"Fundamentos/Arreglos/","page":"Arreglos","title":"Arreglos","text":"La función calcular_coordenadas(V, E) debe aceptar un arreglo V que define el conjunto de nodos y E que define el conjunto de aristas, y debe devolver un vector de tuplas donde cada tupla corresponde a la coordenada x e y de cada nodo. Ejemplos de entrada son V = 1:4, E = [(1, 2), (2, 3), (3, 4), (4, 1)], que define un cuadrado, y V = 1:6, E = [(1, 2), (1, 5), (2, 5), (2, 4), (3, 4), (3, 6), (4, 6)] según la Fig. 2 del artículo citado.","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/#Entorno-de-desarrollo","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"","category":"section"},{"location":"Herramientas/Entorno_de_desarrollo/#Instalación-de-Julia","page":"Entorno de desarrollo","title":"Instalación de Julia","text":"","category":"section"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Para utilizar Julia en el curso recomendamos descargar la ultima version estable para su sistema de la pagina de descargas. Luego se deben seguir las indicaciones de acuerdo a su plataforma como se describe aqui.","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Recomendamos chequear que la instalacion es correcta abriendo el programa julia desde la consola.","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"En cuanto al entorno de desarrollo, recomendamos VSCode. Ver instrucciones de instalacion aqui. Mas adelante estudiaremos a fondo como utilizar VSCode.","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Los contenidos de esta pagina se pueden seguir sin problema desde la terminal, y de hecho es lo que recomendamos, para afianzar el uso del REPL. Para incluir un archivo se utiliza el comando include. Por ejemplo, primero creemos el archivo hola.jl que solo llama al comando println de Julia para imprimir la cadena de caracteres \"Hola, mundo!\":","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"$ echo 'println(\"Hola, mundo!\")' > hola.jl\n\n$ cat hola.jl\nprintln(\"Hola, mundo!\")","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Para correr el programa en Julia, podemos pasarlo como argumento:","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"$ julia hola.jl\nHola, mundo!\n$","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Luego de correr el programa, estamos de nuevo en la linea de comandos. No obstante, podemos cargar el archivo sin cerrar la sesion (REPL) de Julia, primero cargando julia y luego utilizando include como se muestra a continuacion:","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"$ julia\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.7.2 (2022-02-06)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\njulia> include(\"hola.jl\")\nHola, mundo!","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/#Markdown","page":"Entorno de desarrollo","title":"Markdown","text":"","category":"section"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Markdown es otro lenguaje que utilizaremos a menudo para escribir notas y documentación. Además, la plataforma Zulip que utilizaremos para comunicarnos también soporta Markdown. Recomendamos seguir este tutorial para familiarizarse com el formato.","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/#VSCode","page":"Entorno de desarrollo","title":"VSCode","text":"","category":"section"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Se puede descargar VSCode para distintos sistemas aqui. ","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"note: Alternativa: VSCodium\nExiste una version del software llamada VSCodium, donde el archivo binario se desarrolla de manera abierta, otorgando asi un mayor control a los usuarios relativo a la telemetria / uso de datos.","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Instrucciones sobre la extension de Julia para VSCode se encuentran aqui, en particular ver la documentacion de Julia in VSCode.","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/#Control-de-revisión-con-git","page":"Entorno de desarrollo","title":"Control de revisión con git","text":"","category":"section"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Git es una herramienta de control de versiones de código de forma distribuida.","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Trabaja con ramas (branches), que permiten generar proyectos divergentes de un proyecto principal. Git permite fusionar de manera muy eficiente una determinada rama al proyecto principal.","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Al trabajar de forma distribuida, los clientes generan una réplica exacta del proyecto en su computadora local. Esto evita la pérdida de avances frente a problemas de conectividad con la red, como sucede en los sistemas centralizados.","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Además, permite la reproducibilidad del paquete desarrollado, para proporcionar su versión exacta en publicaciones y poder así reproducir los resultados reportados, o si se detectaron bugs, detectar cuándo fueron introducidas.","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/#Git-y-GitHub","page":"Entorno de desarrollo","title":"Git y GitHub","text":"","category":"section"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Git es una herramienta de código abierto diseñada por Linus Torvald (creador de Linux), sobre el sistema operativo Linux, para el control de versiones de código.","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Por otro lado, GitHub (cuyo propietario es Microsoft desde 2018), es una plataforma de desarrollo colaborativo para alojar proyectos utilizando el sistema de control de versiones Git. En particular, Git se puede utilizar sin contar con GitHub, pero no al revés. Sin embargo, usar herramientas como GitHub hacen más sencillo el intercambio de código con otros desarrolladores. GitLab y BitBucket son otras plataformas similares a GitHub.","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"💾 Instalación de Git","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"🚀 GitHub","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"🐙 GitKraken Client (interfaz gráfica de Git)","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/#Crear-un-repositorio-local-de-git","page":"Entorno de desarrollo","title":"Crear un repositorio local de git","text":"","category":"section"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"El primer paso para crear un nuevo proyecto, es crear un nuevo repositorio (repo). Para esto, nos movemos a la carpeta donde estamos trabajando:","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"$ cd miproyecto/","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"y ejectuamos el comando git init:","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"$ git init","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/#Agregar-un-archivo-al-repo","page":"Entorno de desarrollo","title":"Agregar un archivo al repo","text":"","category":"section"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Si agregamos un archivo llamado <nombre_del_archivo> a la carpeta y hacemos:","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"$ git status","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"veremos git reconoce que se han hecho cambios. Un mensaje del estilo \"Untracked files...\" nos dice que git detectó que se ha creado un nuevo archivo pero, a menos que ejecutemos git add, git no hará nada con dicho archivo.","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/#Área/Entorno-de-stage-y-commits","page":"Entorno de desarrollo","title":"Área/Entorno de stage y commits","text":"","category":"section"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Un commit es un registro de todos los cambios realizados desde el último commit que se hizo. Se puede recuperar el estado del proyecto al punto de cualquier commit.","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Las modificaciones del repo que incluimos en un commit son todos aquellos que fueron colocados previamente en el área de stage.","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Para agregar un archivo a un commit, debemos hacer:","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"$ git add <nombre_del_archivo>","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Una vez agregados todos los archivos que se quiera al área de stage, se le puede pedir a git qeue los agregue a un commit.","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/#Agregar-un-archivo-al-entorno-stage","page":"Entorno de desarrollo","title":"Agregar un archivo al entorno stage","text":"","category":"section"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Una vez que se agregó el archivo <nombre_del_archivo> al stage, se pueden ver los cambios con el comando $ git status. Sin embargo, estos cambios aún no han sido agregados al commit.","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/#Crear-un-commit","page":"Entorno de desarrollo","title":"Crear un commit","text":"","category":"section"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Un commit se crea con la siguiente instrucción:","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"$ git commit -m \"mensaje\"","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"El \"mensaje\" debe ser una breve y representativa descripción del contenido del commit. Esto es muy importante, ya que el registro de commits perdura por siempre (a menos de que haya una razón clara de por qué eliminar un commit).","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/#Crear-una-nueva-branch-(rama)","page":"Entorno de desarrollo","title":"Crear una nueva branch (rama)","text":"","category":"section"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"A menos de que se trate de un repo personal, no colaborativo, y que estemos completamente seguros de que queremos incluir modificaciones sobre su contenido, es crucial trabajar en una nueva branch (rama). Por ejemplo, si estamos explorando el desarrollo de una feature del paquete de software, pero no queremos modificar el paquete principal o tememos \"romperlo\" con estos cambios, podemos hacerlo trabajando en una nueva branch.","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Una vez desarrollada la nueva feature, podemos fusionar nuestra branch de trabajo con la rama principal u \"oficial\" del repo (master branch). Esto se hace con el comando merge.","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"El siguiente comando crea una nueva branch llamada <nombre_de_la_nueva_branch> y además nos posiciona en ella:","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"$ git checkout -b <nombre_de_la_nueva_branch>","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Se ejecuta el comando $ git branch, podrá ver la lista de branches creadas y verificar que se creó la nueva branch. Verá que la branch en la que está posicionado está señalada con un asterisco (^*nombre_de_la_nueva_branch).","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Apuntamos que, estrictamente, Git trata a todas las branches por igual. Sin embargo, siempre existe una branch principal u \"oficial\", que, aunque se puede renombrar, se llama master.","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Mientras no hallamos hecho merge de los cambios en nuestra branch, si nos movemos a la princial, haciendo","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"$ git checkout master","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"allí no veremos ninguno de dichos cambios.","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/#Crear-un-nuevo-repositorio-en-GitHub","page":"Entorno de desarrollo","title":"Crear un nuevo repositorio en GitHub","text":"","category":"section"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"GitHub nos permite trabajar en un proyecto de manera colaborativa. Para comenzar, debemos generar un nuevo repo en GitHub. Esto se hace, una vez loggeados, debajo del menú denotado con el símbolo + arriba a la derecha, donde dice New repository.","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"GitHub nos dará la opción de crear un nuevo repo desde cero (from scratch) o subir lo que ya creamos localmente hasta ahora, en nuestra computadora. Para hacer esto último, debemos ir a la sección \"…or push an existing repository from the command line\" y seguir las instrucciones que figuran. Estas son, desde la carpeta principal de nuestro proyecto local:","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"$ git remote add origin <https://github.com/mi_nombre_de_usuario_en_GitHub/nombre_del_repo_creado_en_GitHub.git>\n$ git push -u origin master","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"En este punto, el repo de GitHub contiene nuestra branch principal (master), pero queremos además subir el commit que habíamos creado en la branch <nombre_de_la_nueva_branch>.","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/#push-de-la-branch-a-GitHub","page":"Entorno de desarrollo","title":"push de la branch a GitHub","text":"","category":"section"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Para permitir que otras personas puedan visualizar los cambios hechos en una branch y que, eventualmente, le hagan merge a la branch principal, se debe ejecutar el siguiente comando:","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"$ git push origin <nombre_de_la_nueva_branch>","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"De esta manera, GitHub creará automáticamente la branch <nombre_de_la_nueva_branch> en el repo remoto, con todos los cambios incluidos en el commit que habíamos generado.","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"La palabra origin es un alias que Git creó y que contiene la URL del repo remoto, es decir, https://github.com/mi_nombre_de_usuario_en_GitHub/nombre_del_repo_creado_en_GitHub.git.","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"El paso siguiente es acceder a la página de GitHub y veremos un anuncio que nos da la opción Compare & pull request.","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/#pull-request-(PR)","page":"Entorno de desarrollo","title":"pull request (PR)","text":"","category":"section"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Un pull request (PR) es la forma de alertar a los propietarios del repo de que deseamos hacer cambios sobre él. Le asignamos un nombre y una breve descripción al PR y vamos a Create pull request.","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Si vamos al PR, veremos que tenemos la opción Merge pull request, que significa que hacemos el merge de los cambios en la branch a master. Si somos propietarios o co-propietarios de un repo, no es necesario crear un PR antes de hacer merge de nuestra branch, aunque siempre es una buena práctica crear un PR para tener mejor seguimiento de la evolución del repo.","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/#merge-un-PR","page":"Entorno de desarrollo","title":"merge un PR","text":"","category":"section"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Si clickeamos en Merge pull request, los cambios de nuestra branch serán fusionados en master y, luego, es una práctica eliminar la branch en la que estaba trabajando. Cuando hay demasiadas branches, el repo se vuelve algo \"caótico\". En la misma página en la que hicimos el merge, veremos un botón que dice Delete branch.","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Para verificar que nuestros cambios se han incluido en master, podemos ir a la pestaña Commits y veremos que \"Merge pull request #n\" es el que aparece primero (donde n es el número del PR que hicimos merge).","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Además, en la misma pestaña Commits veremos, junto a cada commit, su hash code. Este hash es un identificador que es único para cada commit. Por ejemplo, si deseamos deshacer cambios y recuperar el estado del proyecto hasta un determinado PR, cuyo hash es código_hash, debemos ejecutar:","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"$ git revert <código_hash>","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/#Traer-los-cambios-de-GitHub-a-nuestra-computadora-(pull)","page":"Entorno de desarrollo","title":"Traer los cambios de GitHub a nuestra computadora (pull)","text":"","category":"section"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Luego de realizar los cambios explicados hasta ahora, veremos que nuestro repo local es diferente al remoto, ya que hay cambios a los que se les hicieron merge a master. Para traer esos cambios, así como los de cualquier otro usiario, a nuestro repo local, debemos usar el comando pull:","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"$ git pull origin master","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Al ejecutar esta instrucción, veremos la lista cambios realizados respecto a nuestra previa versión del repo.","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Para ver la lista de los commits nuevos, podemos ejecutar:","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"$ git log","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"y los veremos ordenados según la fecha de modificación (primero los más recientes).","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"(Previamente nos debimos haber movido a la branch master: $ git checkout master).","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Con el siguiente comando creamos un alias para la instrucción que nos permite visualizar el grafo de modificaciones en el repo:","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"$ git config --global alias.graph \"log --all --graph --decorate --oneline\"","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Ahora, haciendo $ git graph, tendremos una representación de la estructura de branches o grafo del repo, y junto a cada commit se muestra una abreviación del hash correspondiente (7 caracteres en lugar del total de 40 caracteres).","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/#Resolución-de-colisiones","page":"Entorno de desarrollo","title":"Resolución de colisiones","text":"","category":"section"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Las colisiones o conflictos se generan cuando una misma porción de código se intenta modificar desde dos branches diferentes, es decir, se desea hacer git merge. La resolución de estas colisiones consiste en especificarle a Git qué versión debe mantener.","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Cree un archivo materiales.txt en la rama principal de su repo (master), con el siguiente contenido:","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"- mochila\n- cuaderno","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Cree dos branches: una llamada quiero_lapiz y otra llamada quiero_lapicera:","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"$ git branch quiero_lapiz\n$ git branch quiero_lapicera","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"En cada branch haremos un cambio diferente del mismo archivo. En la rama quiero_lapiz agregue el material \"lapiz\" a la lista de materiales. Por otro lado, el la lista quiero_lapicera, en lugar de agregar \"lapiz\", agregue \"lapicera\" (recuerde que en cada caso debe hacer $ git add <nombre_del_archivo> y $ git commit -m \"<mensaje>\"). Una vez hechos los cambios, compruebe las diferencias con master:","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"$ git diff master quiero_lapiz\n$ git diff master quiero_lapicera","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Supongamos que ahora queremos incorporar los cambios en quiero_lapiz a master:","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"$ git checkout master\n$ git status\n$ git merge quiero_lapiz","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Supongamos ahora que queremos agregar los cambios de quiero_lapicera al nuevo estado de master:","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"$ git merge quiero_lapicera","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Veremos que Git ha encontrado un conflicto (de lo contrario, hubiese creado un merge commit automáticamente):","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"$ git status","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Git no va a tomar ninguna decisión, sino que es el usuario quién debe hacerlo. Sin embargo, Git nos da claras instrucciones sobre cómo hacerlo. Abra el archivo conflictivo (materiales.txt), por ej.:","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"$ cat materiales.txt","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"También puede ver las especificaciones de los conflictos con:","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"$ git diff","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"aunque git diff solo muestra los fragmentos conflictivos.","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Git inserta los identificadores <<<<<<< para el estado actual y >>>>>>> para los cambios propuestos (además, ======= oficia de separador).","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"En este momento, pueden darse dos situaciones: (a) deseamos abortar el merge, o (b) deseamos resolver el conflicto.","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/#(a)-Abortar-el-merge","page":"Entorno de desarrollo","title":"(a) Abortar el merge","text":"","category":"section"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Puede suceder que no podamos resolver el conflicto hasta comunicarnos con algún colega. En ese caso, podemos abortar el merge y restaurar el repo a HEAD (estado que tenía en el último commit):","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"$ git merge --abort","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/#(b)-Resolución-del-conflicto-de-forma-manual","page":"Entorno de desarrollo","title":"(b) Resolución del conflicto de forma manual","text":"","category":"section"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Veamos cómo resolver el conflicto de forma manual (en la práctica, podremos también hacerlo con herramientas como VSCode o GirtKraken). Los pasos son los siguientes (puede ayudarse de $ git graph para ver la estrucutra de ramas en cada etapa):","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Ver el status del repo con $ git status y $ git diff.\nEditar el archivo (materiales.txt) y editarlo con las modificaciones que se deseen (incluso pueden mantenerse los cambios propuestos en ambas branches o hasta eliminar ambos). Se deben quitar los identificadores (<<<<<<<, >>>>>>> y =======).\nRepetir el primer paso para revisar el nuevo status del repo: $ git status y $ git diff.\nIndicar a Git que ya hemos resuelto el conflicto: $ git add materiales.txt.\nVolver a inspeccionar el status del repo: $ git status.\nRealizar el commit del merge. Alcanza ejecutar $ git commit.","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/#Preguntas:","page":"Entorno de desarrollo","title":"Preguntas:","text":"","category":"section"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"¿Qué sucede con el conflicto detectado si en las dos branches se hubiesen hecho los mismos cambios?\nSuponga que desde la branch quiero_lapiz hace el commit de sus cambios y luego, desde esa misma branch crea una nueva branch que llama quiero_lapicera. Luego, desde quiero_lapicera agrega nuevos cambios y procede a hacer su commit. Si ahora hace merge de ambas branches, ¿qué conflicto detecta?","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/#Comandos-útiles","page":"Entorno de desarrollo","title":"Comandos útiles","text":"","category":"section"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Una lista de los comandos básicos de git se puede encontrar en este link.","category":"page"},{"location":"Herramientas/Entorno_de_desarrollo/#Referencias","page":"Entorno de desarrollo","title":"Referencias","text":"","category":"section"},{"location":"Herramientas/Entorno_de_desarrollo/","page":"Entorno de desarrollo","title":"Entorno de desarrollo","text":"Documentacion de Julia\nForo de Julia\nIntroduction to version control with Git","category":"page"},{"location":"Herramientas/Computacion_numerica/#Computación-numérica","page":"Computación numérica","title":"Computación numérica","text":"","category":"section"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"En computación, la representación de un número real consiste en reemplazarlo por una cantidad finita de dígitos. Este proceso de discretización, implica que todo conjunto de números reales y los resultados de operaciones aritméticas que hagamos con ellos, se verán alterados respecto al valor matemático exacto. Existen algoritmos, llamados inestables, que son extremadamente sensibles a dichas perturbaciones (tal sensibilidad se cuantifica con el condition number). En este apartado, discutiremos cómo se tratan estos aspectos.","category":"page"},{"location":"Herramientas/Computacion_numerica/#Números-de-punto-flotante","page":"Computación numérica","title":"Números de punto flotante","text":"","category":"section"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"El conjunto de los números reales mathbbR es infinito en dos sentidos: no es acotado y es contínuo. En computación numérica, reemplazamos mathbbR por el conjunto de números de punto flotante mathbbF, cuyos elementos son el cero y los números de la forma:","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"pm (1 + f) times 2^e","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"donde e es el exponente y 1+f es la mantisa, definda como","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"f = sum_i=1^d b_i 2^-i  b_i in left 01 right","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"con d un número entero fijo. Por lo tanto, fin left01 right) y (1+f)in left12 right). Notar que:","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"f = 2^-dsum_i=1^d b_i 2^d-i = 2^-d z","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"con zin  01dots2^d-1 . Por lo tanto, el conjunto mathbbF contiene 2^d números equiespaciados por 2^e-d, cuyo primer elemento es 2^e y el último es 2^e+1-2^-d.","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"El elemento de mathbbF es 1 y el siguiente es 1+2^-d (para e=0) y, por lo tanto, la precisión de máquina o \"machine epsilon\" se define como varepsilon_mach=2^-d.","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"La función de redondeo mathbffl mapea cada xinmathbbR al elemento mathbffl(x)inmathbbF más cercano. Si x es positivo, sabemos que xin left 2^e 2^e+1 right) para algún e. Por lo tanto,  mathbffl(x) - x  leq frac12(2^e-d) y el error relativo (relative accuracy) de la función de redondeo está acotado por:","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"dfrac mathbffl(x) - x  x  leq frac12varepsilon_mach","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"o, lo que es equivalente:","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"mathbffl(x) = x (1+varepsilon) mathrmparaalgún varepsilonleq frac12varepsilon_mach","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"Por otro lado, la precisión (precision) de un número de punto flotante es siempre d dígitos binarios.","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"Según el estándar IEEE 754, se define single (double) precision para d=23 (52) dígitos binarios para la parte fraccional f. En double precision varepsilon_mach=2^-52approx 22times 10^-16.","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"Doble precisión corresponde a 64 bits binarios para representar un número: 52 bits para la mantisa (1+f), 1 bit para el signo y 11 bits para el exponente e. En este caso, el exponente e puede variar de 2^0=1 a 2^11=2048. Como e puede valer 0, los valores posibles de e son de 0 a 2047, donde el 1023 representa el cero. Por lo tanto e=-1023 cuando todos los bits son 0 y e=1024 cuando todos los bits son 1. Sin embargo, estos extremos son reservados para números especiales (NaN y pm infty), se tiene que -1022leq e leq 1023.","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"@show typeof(1)\nx = 1.0\n@show typeof(x)\n@show bitstring(x)\n@show sign(x)\n@show eps(); # machine epsilon\n@show floatmin() floatmax();","category":"page"},{"location":"Herramientas/Computacion_numerica/#Aritmética-de-punto-flotante","page":"Computación numérica","title":"Aritmética de punto flotante","text":"","category":"section"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"Compare:","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"εₘ = eps()/2\n(1.0 + ε) - 1.0","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"con:","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"1.0 + (ε - 1.0)","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"Las operaciones aritméticas en computadoras, son operaciones que se aplican a números de punto flotante y dan como resultado números de punto flotante. Cada operación matemática sobre números reales (suma, resta, multiplicación, división, raíz cuadrada, etc) tienen su análogo de máquina. Las operaciones elementales de máquina dan como resultado números de punto flotante cuyo error relativo está acotado por varepsilon_mach. Por ejemplo, dados x  y in mathbbF, el error de la suma de máquina oplus está acotado por:","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"dfrac(xoplus y)- (x+y)x+yleq varepsilon_mach","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"Por lo tanto, el error de las operaciones de máquina es prácticamente el mismo que el de la propia representación de los números de punto flotante.","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"Volviendo al ejemplo planteado, vemos que (1.0 + ε) - 1.0 da 0 miesntras que 1.0 + (ε - 1.0) da ε (resultado exacto). Para entender este comportamiento, se debe notar que entre 1 y 1+varepsilon_mach2 no hay números de punto flotante, pues, en el intervalo 12), el menor espaciamiento es varepsilon_mach (correspondiente a e=0), por lo que la diferencia da 0. Por otro lado, el espacio entre números de punto flotante en el intervalo 121) es varepsilon_mach2 (para e=-1), por lo tanto 1-varepsilon_mach2 (y, por lo tanto, también su opuesto) se representa de manera exacta. Es por eso que en este último caso, el resultado 1.0 + (ε - 1.0) es el exacto (varepsilon_mach2).","category":"page"},{"location":"Herramientas/Computacion_numerica/#Número-de-condición","page":"Computación numérica","title":"Número de condición","text":"","category":"section"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"Sea tildex=mathbffl(x)=x(1+varepsilon), para algún varepsilonleq varepsilon_mach2. Dada una función fmathbbRtomathbbR, calculamos la tasa de cambio relativo del resultado y de los datos como:","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"dfracdfracf(x)-f(tildex)f(x)dfracx-tildexx=dfracf(x)-f(x(1+varepsilon)) varepsilon f(x) ","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"Se define el condition number relativo para el problema f(x), (kappa_f (x)) tomando el límite para varepsilon_machto 0, es decir, para el caso ideal de una computadora perfecta:","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"kappa_f (x) = lim_varepsilonto 0 dfracf(x)-f(x(1+varepsilon)) varepsilon f(x) =left dfracx f^prime(x)f(x) right","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"El problema de f(x) es mal-condicionado (ill-conditioned) cuando kappa_f (x) es grande, ya que pequeñas perturbaciones del dato x provoca grandes cambios relativos del resultado f(x). En particular, kappa_f (x) grandes son una señal de que el error en el cálculo de la función f(x) no se mantendrá comparable con el error de redondeo de x.","category":"page"},{"location":"Herramientas/Computacion_numerica/#El-problema-de-k-bandits","page":"Computación numérica","title":"El problema de k-bandits","text":"","category":"section"},{"location":"Herramientas/Computacion_numerica/#Evaluacion-de-polinomios","page":"Computación numérica","title":"Evaluacion de polinomios","text":"","category":"section"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"Como ejemplos consideremos el polinomio univariado P_k in mathbbRx dado por","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"P_k(x) = sum_k=0^n dfracx^kk = 1 + x + fracx^22 + ldots + fracx^kk","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"(a) Implementar una funcion evaluar(x) que evalua el polinomio P_k en el valor x.","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"(b) ¿Cuantas multiplicaciones y cuantas divisiones utilizó en la parte anterior, para un valor de k dado? Chequear (o revisar la implementación si no se verifica) que no se utilizan más de 2k multiplicaciones ni más de k divisiones.","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"(c) Implementar la evaluación utilizando el algoritmo de Horner. Revisar el resultado de la parte anterior con el nuevo algoritmo.  ","category":"page"},{"location":"Herramientas/Computacion_numerica/#Iteración-de-punto-fijo","page":"Computación numérica","title":"Iteración de punto fijo","text":"","category":"section"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"Fixed point iteration","category":"page"},{"location":"Herramientas/Computacion_numerica/#Aritmética-de-intervalos","page":"Computación numérica","title":"Aritmética de intervalos","text":"","category":"section"},{"location":"Herramientas/Computacion_numerica/#Descenso-por-gradiente","page":"Computación numérica","title":"Descenso por gradiente","text":"","category":"section"},{"location":"Herramientas/Computacion_numerica/#Referencias","page":"Computación numérica","title":"Referencias","text":"","category":"section"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"","category":"page"},{"location":"Herramientas/Computacion_numerica/#Entregable-3","page":"Computación numérica","title":"Entregable 3","text":"","category":"section"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"warning: Formato de entrega\nEl formato de entrega es análogo al utilizado en los entregables anteriores, ver Ejercicio 1.2 Creación de un repositorio. En particular, todos los ejercicios entregados deben ser parte de un único módulo llamado Entregable_3 que define la constante CI asi como también exporta las funciones que se piden en cada ejercicio entregado. Importante: Además debe incluir los archivos de proyecto (Project.toml y Manifest.toml) en su entrega. ","category":"page"},{"location":"Herramientas/Computacion_numerica/#.1.-Integración-de-Runge-Kutta","page":"Computación numérica","title":"3.1. Integración de Runge-Kutta","text":"","category":"section"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"En este ejercicio trabajamos con ecuaciones diferenciales numéricamente. Sea x = f(x(t) t), x in mathbbR^n, un sistema de ecuaciones diferenciales ordinarias de primer orden en n geq 1 variables. Dentro de la gran variedad de enfoques para integrar numéricamente dichos sistemas se encuentra la familia de métodos de Runge-Kutta. Nos concentramos en el método RK4 (cuarto orden) que se describe a continuación. En dicho método, dado un paso temporal h  0 y un estado inicial x_0 se calcula, para cada k = 0 1ldots N, una secuencia de valores x_1 x_2 ldots x_N mediante la siguiente fórmula explícita:","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"x_k+1 = x_k + hsum_k=1^s b_k w_k","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"Para el esquema que nos interesa utilizamos s = 4 y los coeficientes b_i resultan ser (16 26 26 16). Los términos w_i resultan de evaluar el campo vectorial f en los siguientes puntos intermedios: w_1 = f(x t), w_2 = f(x + hw_1  2 t + h2), w_3 = f(x + hw_2  2 t + h2) y w_4 = f(x + hw_3 t + h).","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"Implementar una función integrate(f::Function, alg::RK4, t0, T, x0) que resuelve el problema de valores iniciales x = f(x(t) t), x(0) = x_0, en el intervalo de tiempo entre t_0 y T. Aquí RK4 es un struct asociado al algoritmo y que debe almacenar el paso h (sin valor por defecto). La función integrate debe devolver un vector con el resultado de la integración.","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"Como caso de ejemplo se considerará la integración de las ecuaciones de Lotka-Volterra:","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"function lotkavolterra(x, t)\n    α, β, γ, δ = 1.5, 1., 3., 1.\n    [α * x[1] - β * x[1] * x[2], δ * x[1] * x[2] - γ * x[2]]\nend","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"entendiéndose que el siguiente comando debe integrar dicho sistema entre t = 0 y t = 10 con paso temporal h = 001 y condición inicial x_0 = 1 1:","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"julia> integrate(lotkavolterra, RK4(h=0.01), 0.0, 1.0, ones(2))","category":"page"},{"location":"Herramientas/Computacion_numerica/#.2.-Evaluación-de-polinomios-por-el-método-de-Bernstein","page":"Computación numérica","title":"3.2. Evaluación de polinomios por el método de Bernstein","text":"","category":"section"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"En este ejercicio trabajamos con polinomios univariados p  mathbbR to mathbbR, cuyos coeficientes en la base de potencias notamos a_i_i=0^l siendo l in mathbbN el grado del polinomio (a_l neq 0). Tiene así a lo sumo l+1 términos (monomios) no nulos y escribimos:","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"p(x) = a_0 + a_1 x + ldots + a_l x^l","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"Para trabajar con polinomios univariados en Julia utilizaremos Polynomials.jl. Por ejemplo, sea","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"p(x) = 3x^2 - 2x + 1","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"Podemos definirlo como un Polynomials.Polynomial así:","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"julia> using Polynomials\n\njulia> p = Polynomial([1, -2, 3])\nPolynomial(1 - 2*x + 3*x^2)","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"Nótese que el órden más bajo se ingresa primero. Consultar la documentación de Polynomials.jl por más casos de uso.","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"El método llamado expansion de Bernstein permite, entre otras cosas, calcular extremos (máximos y mínimos) de polinomios en un dominio dado, de manera aproximada pero rápida. Dicho método también aplica a polinomios multivariados, pero dejaremos esa generalización para un entregable futuro. Como referencia, tanto para el caso univariado como para el multivariado, ver Enclosure Methods for Systems of Polynomial Equations and Inequalities de A. P. Smith (2012).","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"El primer paso en este ejercicio consiste en implementar una función","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"bernstein_basis(l::Int, i::Int)::Function","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"que devuelve el polinomio de Bernstein i-ésimo de grado l, definido mediante la fórmula","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"B_i^l(x) = binomlix^i (1 - x)^l-iqquad i = 0 ldots l","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"Se adopta la convención de que B_i^l(x) = 0 para todo x si i  0 o si i  l.","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"Por ejemplo, B^3_1(x) = 3x^3 - 6x^2 + 3x:","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"julia> p = bernstein_basis(3, 1)\n#1 (generic function with 1 method)\n\njulia> p_test = Polynomial([0, 3, -6, 3])\nPolynomial(3*x - 6*x^2 + 3*x^3)\n\njulia> sum(abs(p(x) - p_test(x)) for x in rand(1_000))\n5.703991186984617e-14","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"Se recomienda corroborar su implementación con los gráficos de la Figura 3.1 de la citada tesis.","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"Dado un polinomio en la base de potencias","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"p(x) = sum_i=0^l a_i x^i","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"su expresión en la base de Bernstein de grado l en el dominio unitario X = 0 1 es:","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"p(x) = sum_i=0^l b_i B_i^l(x)","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"con l + 1 coeficientes b_i a determinar. Por ejemplo:","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"p(x) = -5x^2 + 2x + 3 = 3(1 - 2x+x^2) + 4(2x - 2x^2) = 3 B_0^2(x) + 4B_1^2(x)","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"Así, en este ejemplo los coeficientes en la base de potencias son (a_0 a_1 a_2) = (3 2 -5) mientras que los coeficientes en la base de Bernstein de grado l = 2 son (b_0 b_1 b_2) = (3 4 0).","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"Implementar una función","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"bernstein_coefficients(pol::Polynomial)::Vector","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"que permite convertir de la base de potencias a la base de Bernstein. La conversión se puede lograr mediante la siguiente fórmula (ver Teorema (3.2) de la citada tesis para la demostración):","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"b_i = sum_j = 0^i dfracbinomijbinomlja_jqquad 0 leq i leq l","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"En el ejemplo anterior,","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"julia> p = Polynomial([3, 2, -5])\nPolynomial(3 + 2*x - 5*x^2)\n\njulia> bernstein_coefficients(p)\n[3, 4, 0]","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"Cuando el dominio de interés no es el intervalo unitario, se requiere utilizar una fórmula de transformacion generalizada. Sea X = underlinex barx un dominio (intervalo) arbitrario, underlinex   barx. Implementar una función","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"bernstein_coefficients(pol::Polynomial, X::Tuple{Number,Number})::Vector","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"que recibe un polinomio y devuelve en un vector los l+1 coeficientes de Bernstein b_i asociados de grado l en X (representado como una tupla de números). Para ello se utilizará el siguiente resultado (ver ecuación (3.13) de la citada tesis):","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"b_i = sum_j=0^i dfracbinomijbinomlj(barx - underlinex)^j sum_k=j^l binomkjunderlinex^k-ja_kqquad 0 leq i leq l","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"Una de las propiedades más interesantes de la expansión de Bernstein es que los coeficientes de la expansión contienen información sobre el rango del polinomio en el dominio X dado, resultado que se conoce como Bernstein enclosure. Concretamente,","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"min_i  b_i  leq p(x) leq max_i b_iqquad x in X ","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"Implementar una función","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"bernstein_enclosure(pol::Polynomial, X::Tuple{Number,Number})::Tuple{Number,Number}","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"que devuelve una tupla con la estimación del rango de p(x) utilizando el método de Bernstein.","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"En síntesis, este ejercicio requiere implementar las siguientes funciones:","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"bernstein_basis(l::Int, i::Int)::Function\nbernstein_coefficients(pol::Polynomial)::Vector\nbernstein_coefficients(pol::Polynomial, X::Tuple{Number,Number})::Vector\nbernstein_enclosure(pol::Polynomial, X::Tuple{Number,Number})::Tuple{Number,Number}","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"","category":"page"},{"location":"Herramientas/Computacion_numerica/#Entregable-4","page":"Computación numérica","title":"Entregable 4","text":"","category":"section"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"warning: Formato de entrega\nEl formato de entrega es análogo al utilizado en los entregables anteriores, ver Ejercicio 1.2 Creación de un repositorio. En particular, todos los ejercicios entregados deben ser parte de un único módulo llamado Entregable_4 que define la constante CI asi como también exporta las funciones que se piden en cada ejercicio entregado. Importante: Además debe incluir los archivos de proyecto (Project.toml y Manifest.toml) en su entrega. ","category":"page"},{"location":"Herramientas/Computacion_numerica/#.1.-Método-UCB-para-el-problema-de-k-bandits","page":"Computación numérica","title":"4.1. Método UCB para el problema de k-bandits","text":"","category":"section"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"En este ejercicio revisitamos el problema de k-bandits trabajado en clase. Se implementará el algoritmo llamado upper-confidence-bound (UCB) que se describe a continuación. Sea A_t la acción seleccionada en el tiempo t para t = 1 ldots N pasos de tiempo, y sea Q_t(a) el promedio de recompensas recibido de la acción a a tiempo t.","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"El algoritmo UCB utiliza la siguiente lógica:","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"A_t = argmax_a left( Q_t(a) + c sqrtdfracln tN_t(a) right)","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"donde ln t es el logaritmo (natural) del número de jugada actual, N_t(a) es el número de veces que la acción a ha sido seleccionada anteriormente a la jugada t-ésima, y la constante c  0 es un parámetro del algoritmo que controla el grado de exploración. Si N_t(a) es igual a cero, se considera que a maximiza la expresión. Si hay más de un maximizador, se escoge uno de ellos al azar (de manera uniforme).","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"La idea del algoritmo es seleccionar aquellas acciones (\"palancas\") de acuerdo a su potencial de ser óptimas, tomando en cuenta tanto el estimado del mejor valor actual, como también la incertidumbre asociada a dicha estimación.","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"Extender la función simular trabajada en clase agregando el método:","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"simular(J::Juego, alg::UCB; budget::Int = 1000)","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"que implementa el algoritmo anterior. Se utilizará un struct UCB asociado al algoritmo que debe almacenar el parámetro de diseño, con un valor por defecto de c=2.","category":"page"},{"location":"Herramientas/Computacion_numerica/#.2.-Conjunto-alcanzable-mediante-simulaciones","page":"Computación numérica","title":"4.2. Conjunto alcanzable mediante simulaciones","text":"","category":"section"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"En este ejercicio construimos sobre el Ejercicio 3.1 combinando las simluaciones con conjuntos en espacios Euclídeos. Se debe escribir una función reachable_set(f::Function, ::RK4, t0, T, X0::Box) que devuelve otro conjunto Y tal que Y es una estimación, obtenida mediante simulación numérica de los estados alcanzables en el tiempo T.","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"Independiente de la implementación de Box utilizada, ésta debe admitir un constructor con centro (vector) y radio (escalar), e.g. Box([1.0, 1.0], 1.0) que representa el conjunto x in mathbbR^2 Vert x - cVert_infty leq 1  donde c es el centro (en el ejemplo, c = 1 1).","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"Para la estimación se utilizará el algoritmo RK4 y para el muestreo de X_0 se utilizará una secuencia de Sobol, pudiéndose utilizar el paquete Sobol.jl para tal fin. La ventaja que tiene utilizar dichas secuencias es que generan una distribución que cubre \"cuasi-regularmente\" el conjunto de partida.","category":"page"},{"location":"Herramientas/Computacion_numerica/#.3.-Expansión-rápida-de-Bernstein-para-polinomios-univariados","page":"Computación numérica","title":"4.3. Expansión rápida de Bernstein para polinomios univariados","text":"","category":"section"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"En este ejercicio revisitamos la expansión de Bernstein para polinomios univariados del Ejercicio 3.2. Se debe implementar una versión optimizada utilizando el resultado de la Sección 9.2.1 de la tesis de A. P. Smith. Se deben implementar los siguientes métodos:","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"bernstein_coefficients(pol::Polynomial, alg::Algorithm=Fast())::Vector\nbernstein_coefficients(pol::Polynomial, X::Tuple{Number,Number}, alg::Algorithm=Fast())::Vector\nbernstein_enclosure(pol::Polynomial, X::Tuple{Number,Number}, alg::Algorithm=Fast())::Tuple{Number,Number}","category":"page"},{"location":"Herramientas/Computacion_numerica/","page":"Computación numérica","title":"Computación numérica","text":"siendo Fast un struct que representa el nuevo algoritmo y Naive un struct que representa el algoritmo anterior. Comparar el tiempo de ejecución y el número de alocaciones de cada algoritmo utilizando BenchmarkTools.jl.","category":"page"},{"location":"Fundamentos/Estructuras de datos/#Estructuras-de-datos","page":"Estructuras de datos","title":"Estructuras de datos","text":"","category":"section"},{"location":"Fundamentos/Estructuras de datos/#Tipos-abstractos","page":"Estructuras de datos","title":"Tipos abstractos","text":"","category":"section"},{"location":"Fundamentos/Estructuras de datos/#Tipos-concretos","page":"Estructuras de datos","title":"Tipos concretos","text":"","category":"section"},{"location":"Fundamentos/Estructuras de datos/#Tipos-parametricos","page":"Estructuras de datos","title":"Tipos parametricos","text":"","category":"section"},{"location":"Fundamentos/Estructuras de datos/","page":"Estructuras de datos","title":"Estructuras de datos","text":"–","category":"page"},{"location":"Fundamentos/Estructuras de datos/#Ejercicios","page":"Estructuras de datos","title":"Ejercicios","text":"","category":"section"}]
}
