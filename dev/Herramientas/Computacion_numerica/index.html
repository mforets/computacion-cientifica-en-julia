<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Computación numérica · Computación Científica en Julia</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/aligned.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Computación Científica en Julia</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Generalidades</a></li><li><a class="tocitem" href="../../proyectos/">Proyectos</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Herramientas básicas</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../Alcance_del_curso/">Alcance del curso</a></li><li><a class="tocitem" href="../Entorno_de_desarrollo/">Entorno de desarrollo</a></li><li><a class="tocitem" href="../Primeros_pasos_en_Julia/">Primeros pasos en Julia</a></li><li class="is-active"><a class="tocitem" href>Computación numérica</a><ul class="internal"><li><a class="tocitem" href="#Números-de-punto-flotante"><span>Números de punto flotante</span></a></li><li><a class="tocitem" href="#Aritmética-de-punto-flotante"><span>Aritmética de punto flotante</span></a></li><li><a class="tocitem" href="#Número-de-condición"><span>Número de condición</span></a></li><li><a class="tocitem" href="#El-problema-de-k-bandits"><span>El problema de k-bandits</span></a></li><li><a class="tocitem" href="#Evaluacion-de-polinomios"><span>Evaluacion de polinomios</span></a></li><li><a class="tocitem" href="#Iteración-de-punto-fijo"><span>Iteración de punto fijo</span></a></li><li><a class="tocitem" href="#Aritmética-de-intervalos"><span>Aritmética de intervalos</span></a></li><li><a class="tocitem" href="#Descenso-por-gradiente"><span>Descenso por gradiente</span></a></li><li><a class="tocitem" href="#Referencias"><span>Referencias</span></a></li><li><a class="tocitem" href="#Entregable-3"><span>Entregable 3</span></a></li><li><a class="tocitem" href="#Entregable-4"><span>Entregable 4</span></a></li></ul></li><li><a class="tocitem" href="../Computacion_simbolica/">Computación simbólica</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Fundamentos de Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Fundamentos/Tipos de datos basicos/">Tipos de datos básicos</a></li><li><a class="tocitem" href="../../Fundamentos/Reglas de alcance/">Reglas de alcance</a></li><li><a class="tocitem" href="../../Fundamentos/Arreglos/">Arreglos</a></li><li><a class="tocitem" href="../../Fundamentos/Gestor de paquetes/">Gestor de paquetes</a></li><li><a class="tocitem" href="../../Fundamentos/Estructuras de datos/">Estructuras de datos</a></li><li><a class="tocitem" href="../../Fundamentos/Funciones/">Funciones</a></li><li><a class="tocitem" href="../../Fundamentos/Mecanismos de evaluacion/">Mecanismos de evaluacion</a></li><li><a class="tocitem" href="../../Fundamentos/Metaprogramacion/">Metaprogramación</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Patrones de diseño</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Patrones/paquetes/">Generación de paquetes</a></li><li><a class="tocitem" href="../../Patrones/reutilizacion/">Patrones para reutilización de código</a></li><li><a class="tocitem" href="../../Patrones/docs/">Documentación de código</a></li><li><a class="tocitem" href="../../Patrones/performance/">Patrones para performance</a></li><li><a class="tocitem" href="../../Patrones/debugging/">Patrones de robustez</a></li><li><a class="tocitem" href="../../Patrones/programacion_generica/">Programación genérica</a></li><li><a class="tocitem" href="../../Patrones/programacion_paralela/">Programación paralela</a></li><li><a class="tocitem" href="../../Patrones/antipatrones/">Anti-patrones</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Librerías</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Ecosistema/graficos_pub/">Gráficos para publicaciones</a></li><li><a class="tocitem" href="../../Ecosistema/jump/">Optimización</a></li><li><a class="tocitem" href="../../Ecosistema/sciml/">Modelado y simulaciones numericas</a></li><li><a class="tocitem" href="../../Ecosistema/flux/">Aprendizaje automático</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Herramientas básicas</a></li><li class="is-active"><a href>Computación numérica</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Computación numérica</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mforets/computacion-cientifica-en-julia/blob/master/docs/src/Herramientas/Computacion_numerica.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Computación-numérica"><a class="docs-heading-anchor" href="#Computación-numérica">Computación numérica</a><a id="Computación-numérica-1"></a><a class="docs-heading-anchor-permalink" href="#Computación-numérica" title="Permalink"></a></h1><p>En computación, la representación de un número real consiste en reemplazarlo por una cantidad finita de dígitos. Este proceso de discretización, implica que todo conjunto de números reales y los resultados de operaciones aritméticas que hagamos con ellos, se verán alterados respecto al valor matemático exacto. Existen algoritmos, llamados inestables, que son extremadamente sensibles a dichas perturbaciones (tal sensibilidad se cuantifica con el <a href="https://en.wikipedia.org/wiki/Condition_number">condition number</a>). En este apartado, discutiremos cómo se tratan estos aspectos.</p><h2 id="Números-de-punto-flotante"><a class="docs-heading-anchor" href="#Números-de-punto-flotante">Números de punto flotante</a><a id="Números-de-punto-flotante-1"></a><a class="docs-heading-anchor-permalink" href="#Números-de-punto-flotante" title="Permalink"></a></h2><p>El conjunto de los números reales <span>$\mathbb{R}$</span> es infinito en dos sentidos: no es acotado y es contínuo. En computación numérica, reemplazamos <span>$\mathbb{R}$</span> por el conjunto de números de punto flotante <span>$\mathbb{F}$</span>, cuyos elementos son el cero y los números de la forma:</p><p class="math-container">\[\pm (1 + f) \times 2^e\]</p><p>donde <span>$e$</span> es el exponente y <span>$1+f$</span> es la mantisa, definda como</p><p class="math-container">\[f = \sum_{i=1}^d b_i 2^{-i}, \ b_i \in \left\{ 0,1 \right\}\]</p><p>con <span>$d$</span> un número entero fijo. Por lo tanto, <span>$f\in \left[0,1 \right)$</span> y <span>$(1+f)\in \left[1,2 \right)$</span>. Notar que:</p><p class="math-container">\[f = 2^{-d}\sum_{i=1}^d b_i 2^{d-i} = 2^{-d} z\]</p><p>con <span>$z\in \{ 0,1,\dots,2^d-1 \}$</span>. Por lo tanto, el conjunto <span>$\mathbb{F}$</span> contiene <span>$2^d$</span> números equiespaciados por <span>$2^{e-d}$</span>, cuyo primer elemento es <span>$2^e$</span> y el último es <span>$2^{e+1}-2^{-d}$</span>.</p><p>El elemento de <span>$\mathbb{F}$</span> es 1 y el siguiente es <span>$1+2^{-d}$</span> (para <span>$e=0$</span>) y, por lo tanto, la precisión de máquina o &quot;machine epsilon&quot; se define como <span>$\varepsilon_{mach}=2^{-d}$</span>.</p><p>La función de redondeo <span>$\mathbf{fl}$</span> mapea cada <span>$x\in\mathbb{R}$</span> al elemento <span>$\mathbf{fl}(x)\in\mathbb{F}$</span> más cercano. Si <span>$x$</span> es positivo, sabemos que <span>$x\in \left[ 2^e, 2^{e+1} \right)$</span> para algún <span>$e$</span>. Por lo tanto, <span>$| \mathbf{fl}(x) - x | \leq \frac{1}{2}(2^{e-d})$</span> y el error relativo (relative accuracy) de la función de redondeo está acotado por:</p><p class="math-container">\[\dfrac{| \mathbf{fl}(x) - x |}{| x |} \leq \frac{1}{2}\varepsilon_{mach}\]</p><p>o, lo que es equivalente:</p><p class="math-container">\[\mathbf{fl}(x) = x (1+\varepsilon) \mathrm{,~para~algún~} |\varepsilon|\leq \frac{1}{2}\varepsilon_{mach}\]</p><p>Por otro lado, la precisión (precision) de un número de punto flotante es siempre <span>$d$</span> dígitos binarios.</p><p>Según el estándar <em>IEEE 754</em>, se define single (double) precision para <span>$d=23$</span> (<span>$52$</span>) dígitos binarios para la parte fraccional <span>$f$</span>. En double precision <span>$\varepsilon_{mach}=2^{-52}\approx 2.2\times 10^{-16}$</span>.</p><p>Doble precisión corresponde a 64 bits binarios para representar un número: 52 bits para la mantisa (<span>$1+f$</span>), 1 bit para el signo y 11 bits para el exponente <span>$e$</span>. En este caso, el exponente <span>$e$</span> puede variar de <span>$2^0=1$</span> a <span>$2^11=2048$</span>. Como <span>$e$</span> puede valer <span>$0$</span>, los valores posibles de <span>$e$</span> son de <span>$0$</span> a <span>$2047$</span>, donde el <span>$1023$</span> representa el cero. Por lo tanto <span>$e=-1023$</span> cuando todos los bits son 0 y <span>$e=1024$</span> cuando todos los bits son 1. Sin embargo, estos extremos son reservados para números especiales (<span>$NaN$</span> y <span>$\pm \infty$</span>), se tiene que <span>$-1022\leq e \leq 1023$</span>.</p><pre><code class="language-julia hljs">@show typeof(1)
x = 1.0
@show typeof(x)
@show bitstring(x)
@show sign(x)
@show eps(); # machine epsilon
@show floatmin() floatmax();</code></pre><h2 id="Aritmética-de-punto-flotante"><a class="docs-heading-anchor" href="#Aritmética-de-punto-flotante">Aritmética de punto flotante</a><a id="Aritmética-de-punto-flotante-1"></a><a class="docs-heading-anchor-permalink" href="#Aritmética-de-punto-flotante" title="Permalink"></a></h2><p>Compare:</p><pre><code class="language-julia hljs">εₘ = eps()/2
(1.0 + ε) - 1.0</code></pre><p>con:</p><pre><code class="language-julia hljs">1.0 + (ε - 1.0)</code></pre><p>Las operaciones aritméticas en computadoras, son operaciones que se aplican a números de punto flotante y dan como resultado números de punto flotante. Cada operación matemática sobre números reales (suma, resta, multiplicación, división, raíz cuadrada, etc) tienen su análogo de máquina. Las operaciones elementales de máquina dan como resultado números de punto flotante cuyo error relativo está acotado por <span>$\varepsilon_{mach}$</span>. Por ejemplo, dados <span>$x, \ y \in \mathbb{F}$</span>, el error de la suma de máquina <span>$\oplus$</span> está acotado por:</p><p class="math-container">\[\dfrac{|(x\oplus y)- (x+y)|}{|x+y|}\leq \varepsilon_{mach}\]</p><p>Por lo tanto, el error de las operaciones de máquina es prácticamente el mismo que el de la propia representación de los números de punto flotante.</p><p>Volviendo al ejemplo planteado, vemos que <code>(1.0 + ε) - 1.0</code> da <span>$0$</span> miesntras que <code>1.0 + (ε - 1.0)</code> da <code>ε</code> (resultado exacto). Para entender este comportamiento, se debe notar que entre <span>$1$</span> y <span>$1+\varepsilon_{mach}/2$</span> no hay números de punto flotante, pues, en el intervalo <span>$[1,2)$</span>, el menor espaciamiento es <span>$\varepsilon_{mach}$</span> (correspondiente a <span>$e=0$</span>), por lo que la diferencia da <span>$0$</span>. Por otro lado, el espacio entre números de punto flotante en el intervalo <span>$[1/2,1)$</span> es <span>$\varepsilon_{mach}/2$</span> (para <span>$e=-1$</span>), por lo tanto <span>$1-\varepsilon_{mach}/2$</span> (y, por lo tanto, también su opuesto) se representa de manera exacta. Es por eso que en este último caso, el resultado <code>1.0 + (ε - 1.0)</code> es el exacto (<span>$\varepsilon_{mach}/2$</span>).</p><h2 id="Número-de-condición"><a class="docs-heading-anchor" href="#Número-de-condición">Número de condición</a><a id="Número-de-condición-1"></a><a class="docs-heading-anchor-permalink" href="#Número-de-condición" title="Permalink"></a></h2><p>Sea <span>$\tilde{x}=\mathbf{fl}(x)=x(1+\varepsilon)$</span>, para algún <span>$|\varepsilon|\leq \varepsilon_{mach}/2$</span>. Dada una función <span>$f:\mathbb{R}\to\mathbb{R}$</span>, calculamos la tasa de cambio relativo del resultado y de los datos como:</p><p class="math-container">\[\dfrac{\dfrac{|f(x)-f(\tilde{x})|}{|f(x)|}}{\dfrac{|x-\tilde{x}|}{|x|}}=\dfrac{|f(x)-f(x(1+\varepsilon))|}{| \varepsilon f(x) |}\]</p><p>Se define el condition number relativo para el problema <span>$f(x)$</span>, (<span>$\kappa_f (x)$</span>) tomando el límite para <span>$\varepsilon_{mach}\to 0$</span>, es decir, para el caso ideal de una computadora perfecta:</p><p class="math-container">\[\kappa_f (x) = \lim_{\varepsilon\to 0} \dfrac{|f(x)-f(x(1+\varepsilon))|}{| \varepsilon f(x) |}=\left| \dfrac{x f^\prime(x)}{f(x)} \right|\]</p><p>El problema de <span>$f(x)$</span> es mal-condicionado (<em>ill-conditioned</em>) cuando <span>$\kappa_f (x)$</span> es grande, ya que pequeñas perturbaciones del dato <span>$x$</span> provoca grandes cambios relativos del resultado <span>$f(x)$</span>. En particular, <span>$\kappa_f (x)$</span> grandes son una señal de que el error en el cálculo de la función <span>$f(x)$</span> no se mantendrá comparable con el error de redondeo de <span>$x$</span>.</p><h2 id="El-problema-de-k-bandits"><a class="docs-heading-anchor" href="#El-problema-de-k-bandits">El problema de k-bandits</a><a id="El-problema-de-k-bandits-1"></a><a class="docs-heading-anchor-permalink" href="#El-problema-de-k-bandits" title="Permalink"></a></h2><h2 id="Evaluacion-de-polinomios"><a class="docs-heading-anchor" href="#Evaluacion-de-polinomios">Evaluacion de polinomios</a><a id="Evaluacion-de-polinomios-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluacion-de-polinomios" title="Permalink"></a></h2><p>Como ejemplos consideremos el polinomio univariado <span>$P_k \in \mathbb{R}[x]$</span> dado por</p><p class="math-container">\[P_k(x) := \sum_{k=0}^n \dfrac{x^k}{k!} = 1 + x + \frac{x^2}{2!} + \ldots + \frac{x^k}{k!}.\]</p><p>(a) Implementar una funcion <code>evaluar(x)</code> que evalua el polinomio <span>$P_k$</span> en el valor <span>$x$</span>.</p><p>(b) ¿Cuantas multiplicaciones y cuantas divisiones utilizó en la parte anterior, para un valor de <span>$k$</span> dado? Chequear (o revisar la implementación si no se verifica) que no se utilizan más de <span>$2k$</span> multiplicaciones ni más de <span>$k$</span> divisiones.</p><p>(c) Implementar la evaluación utilizando el <a href="https://es.wikipedia.org/wiki/Algoritmo_de_Horner">algoritmo de Horner</a>. Revisar el resultado de la parte anterior con el nuevo algoritmo.  </p><h2 id="Iteración-de-punto-fijo"><a class="docs-heading-anchor" href="#Iteración-de-punto-fijo">Iteración de punto fijo</a><a id="Iteración-de-punto-fijo-1"></a><a class="docs-heading-anchor-permalink" href="#Iteración-de-punto-fijo" title="Permalink"></a></h2><p><a href="https://fncbook.github.io/v1.0/nonlineqn/demos/fp-spiral.html">Fixed point iteration</a></p><h2 id="Aritmética-de-intervalos"><a class="docs-heading-anchor" href="#Aritmética-de-intervalos">Aritmética de intervalos</a><a id="Aritmética-de-intervalos-1"></a><a class="docs-heading-anchor-permalink" href="#Aritmética-de-intervalos" title="Permalink"></a></h2><p>¿Biblio?</p><h2 id="Descenso-por-gradiente"><a class="docs-heading-anchor" href="#Descenso-por-gradiente">Descenso por gradiente</a><a id="Descenso-por-gradiente-1"></a><a class="docs-heading-anchor-permalink" href="#Descenso-por-gradiente" title="Permalink"></a></h2><h2 id="Referencias"><a class="docs-heading-anchor" href="#Referencias">Referencias</a><a id="Referencias-1"></a><a class="docs-heading-anchor-permalink" href="#Referencias" title="Permalink"></a></h2><hr/><h2 id="Entregable-3"><a class="docs-heading-anchor" href="#Entregable-3">Entregable 3</a><a id="Entregable-3-1"></a><a class="docs-heading-anchor-permalink" href="#Entregable-3" title="Permalink"></a></h2><div class="admonition is-warning"><header class="admonition-header">Formato de entrega</header><div class="admonition-body"><p>El formato de entrega es análogo al utilizado en los entregables anteriores, ver <a href="https://mforets.github.io/computacion-cientifica-en-julia/dev/Herramientas/Entorno_de_desarrollo/#.2.-Creaci%C3%B3n-de-un-repositorio">Ejercicio 1.2 Creación de un repositorio</a>. En particular, todos los ejercicios entregados deben ser parte de un único módulo llamado <code>Entregable_3</code> que define la constante CI asi como también exporta las funciones que se piden en cada ejercicio entregado.</p></div></div><h4 id=".1.-Integración-de-Runge-Kutta"><a class="docs-heading-anchor" href="#.1.-Integración-de-Runge-Kutta">3.1. Integración de Runge-Kutta</a><a id=".1.-Integración-de-Runge-Kutta-1"></a><a class="docs-heading-anchor-permalink" href="#.1.-Integración-de-Runge-Kutta" title="Permalink"></a></h4><p>En este ejercicio se plantea, en primer lugar, implementar el metodo clasico de integracion de Runge-Kutta de orden 4. En segundo lugar, se aplica dicho metodo para resolver una ecuacion diferencial famosa en dinamica de poblaciones, el sistema de Lotka-Volterra (predador-presa).</p><h4 id=".2.-Evaluación-de-polinomios-por-el-método-de-Bernstein"><a class="docs-heading-anchor" href="#.2.-Evaluación-de-polinomios-por-el-método-de-Bernstein">3.2. Evaluación de polinomios por el método de Bernstein</a><a id=".2.-Evaluación-de-polinomios-por-el-método-de-Bernstein-1"></a><a class="docs-heading-anchor-permalink" href="#.2.-Evaluación-de-polinomios-por-el-método-de-Bernstein" title="Permalink"></a></h4><h2 id="Entregable-4"><a class="docs-heading-anchor" href="#Entregable-4">Entregable 4</a><a id="Entregable-4-1"></a><a class="docs-heading-anchor-permalink" href="#Entregable-4" title="Permalink"></a></h2><div class="admonition is-warning"><header class="admonition-header">Formato de entrega</header><div class="admonition-body"><p>El formato de entrega es análogo al utilizado en los entregables anteriores, ver <a href="https://mforets.github.io/computacion-cientifica-en-julia/dev/Herramientas/Entorno_de_desarrollo/#.2.-Creaci%C3%B3n-de-un-repositorio">Ejercicio 1.2 Creación de un repositorio</a>. En particular, todos los ejercicios entregados deben ser parte de un único módulo llamado <code>Entregable_3</code> que define la constante CI asi como también exporta las funciones que se piden en cada ejercicio entregado.</p></div></div><h4 id=".1.-Método-UCB-para-el-problema-de-k-bandits"><a class="docs-heading-anchor" href="#.1.-Método-UCB-para-el-problema-de-k-bandits">4.1. Método UCB para el problema de k-bandits</a><a id=".1.-Método-UCB-para-el-problema-de-k-bandits-1"></a><a class="docs-heading-anchor-permalink" href="#.1.-Método-UCB-para-el-problema-de-k-bandits" title="Permalink"></a></h4><p>Resolver el problema de k-bandits trabajado en clase utilizando el algoritmo de upper-confidence-bound (UCB) que se describe a continuacion. La idea es seleccionar aquellas acciones (palancas) de acuerdo a su potencial de ser optimas, tomando en cuenta tanto el estimado del mejor valor actual, como tambien la incertidumbre en dicha estimacion.</p><p>Sea <span>$A_t$</span> la accion seleccionada en el tiempo <span>$t$</span> para <span>$t = 1, \ldots, N$</span> pasos de tiempo, y sea <span>$Q_t(a)$</span> el <em>promedio</em> de recompensas recibido de la accion <span>$a$</span> a tiempo <span>$t$</span>. El algoritmo UCB utiliza la siguiente logica:</p>$<p>A<em>t := \argmax</em>{a} \left( Q<em>t(a) + c \sqrt{\dfrac{\ln t}{N</em>t(a)}} \right), $ donde <span>$\ln t$</span>es el logaritmo (natural) del numero de jugada actual, <span>$N_t(a)$</span> es el numero de veces que la accion <span>$a$</span> ha sido seleccionada anteriormente a la jugada <span>$t$</span>-esima, y el numero <span>$c &gt; 0$</span> es un parametro del algoritmo que controla el grado de <em>exploracion</em>. Si <span>$N_t(a)$</span> igual a cero, se considera que <span>$a$</span> maximiza la expresion. Aqui <span>$A_t$</span> repre</p><p>Implementar una funcion de firma <code>simular(::Maquina, ::UCB; ::N=1000)</code> que implementa el algoritmo anterior, donde <code>UCB</code> es un struct asociado al algoritmo, con valor por defecto <code>c=2</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Primeros_pasos_en_Julia/">« Primeros pasos en Julia</a><a class="docs-footer-nextpage" href="../Computacion_simbolica/">Computación simbólica »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Wednesday 17 August 2022 07:25">Wednesday 17 August 2022</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
