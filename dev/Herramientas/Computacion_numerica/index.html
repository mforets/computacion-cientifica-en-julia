<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Computación numérica · Computación Científica en Julia</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/aligned.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Computación Científica en Julia</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Generalidades</a></li><li><a class="tocitem" href="../../proyectos/">Proyectos</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Entregables</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Entregables/Entregable1/">Entregable 1</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">Herramientas básicas</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../Alcance_del_curso/">Alcance del curso</a></li><li><a class="tocitem" href="../Entorno_de_desarrollo/">Entorno de desarrollo</a></li><li><a class="tocitem" href="../Primeros_pasos_en_Julia/">Primeros pasos en Julia</a></li><li class="is-active"><a class="tocitem" href>Computación numérica</a><ul class="internal"><li><a class="tocitem" href="#Números-de-punto-flotante"><span>Números de punto flotante</span></a></li><li><a class="tocitem" href="#Aritmética-de-punto-flotante"><span>Aritmética de punto flotante</span></a></li><li><a class="tocitem" href="#Número-de-condición"><span>Número de condición</span></a></li><li><a class="tocitem" href="#El-problema-de-k-bandits"><span>El problema de k-bandits</span></a></li><li><a class="tocitem" href="#Evaluacion-de-polinomios"><span>Evaluacion de polinomios</span></a></li><li><a class="tocitem" href="#Iteración-de-punto-fijo"><span>Iteración de punto fijo</span></a></li><li><a class="tocitem" href="#Aritmética-de-intervalos"><span>Aritmética de intervalos</span></a></li><li><a class="tocitem" href="#Descenso-por-gradiente"><span>Descenso por gradiente</span></a></li><li><a class="tocitem" href="#Referencias"><span>Referencias</span></a></li><li><a class="tocitem" href="#Entregable-3"><span>Entregable 3</span></a></li><li><a class="tocitem" href="#Entregable-4"><span>Entregable 4</span></a></li></ul></li><li><a class="tocitem" href="../Computacion_simbolica/">Computación simbólica</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Fundamentos de Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Fundamentos/Tipos de datos basicos/">Tipos de datos básicos</a></li><li><a class="tocitem" href="../../Fundamentos/Reglas de alcance/">Reglas de alcance</a></li><li><a class="tocitem" href="../../Fundamentos/Arreglos/">Arreglos</a></li><li><a class="tocitem" href="../../Fundamentos/Gestor de paquetes/">Gestor de paquetes</a></li><li><a class="tocitem" href="../../Fundamentos/Estructuras de datos/">Estructuras de datos</a></li><li><a class="tocitem" href="../../Fundamentos/Funciones/">Funciones</a></li><li><a class="tocitem" href="../../Fundamentos/Mecanismos de evaluacion/">Mecanismos de evaluacion</a></li><li><a class="tocitem" href="../../Fundamentos/Metaprogramacion/">Metaprogramación</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Patrones de diseño</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Patrones/paquetes/">Generación de paquetes</a></li><li><a class="tocitem" href="../../Patrones/reutilizacion/">Patrones para reutilización de código</a></li><li><a class="tocitem" href="../../Patrones/docs/">Documentación de código</a></li><li><a class="tocitem" href="../../Patrones/performance/">Patrones para performance</a></li><li><a class="tocitem" href="../../Patrones/debugging/">Patrones de robustez</a></li><li><a class="tocitem" href="../../Patrones/programacion_generica/">Programación genérica</a></li><li><a class="tocitem" href="../../Patrones/programacion_paralela/">Programación paralela</a></li><li><a class="tocitem" href="../../Patrones/antipatrones/">Anti-patrones</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Librerías</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Ecosistema/graficos_pub/">Gráficos para publicaciones</a></li><li><a class="tocitem" href="../../Ecosistema/jump/">Optimización</a></li><li><a class="tocitem" href="../../Ecosistema/sciml/">Modelado y simulaciones numericas</a></li><li><a class="tocitem" href="../../Ecosistema/flux/">Aprendizaje automático</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Herramientas básicas</a></li><li class="is-active"><a href>Computación numérica</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Computación numérica</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mforets/computacion-cientifica-en-julia/blob/master/docs/src/Herramientas/Computacion_numerica.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Computación-numérica"><a class="docs-heading-anchor" href="#Computación-numérica">Computación numérica</a><a id="Computación-numérica-1"></a><a class="docs-heading-anchor-permalink" href="#Computación-numérica" title="Permalink"></a></h1><p>En computación, la representación de un número real consiste en reemplazarlo por una cantidad finita de dígitos. Este proceso de discretización, implica que todo conjunto de números reales y los resultados de operaciones aritméticas que hagamos con ellos, se verán alterados respecto al valor matemático exacto. Existen algoritmos, llamados inestables, que son extremadamente sensibles a dichas perturbaciones (tal sensibilidad se cuantifica con el <a href="https://en.wikipedia.org/wiki/Condition_number">condition number</a>). En este apartado, discutiremos cómo se tratan estos aspectos.</p><h2 id="Números-de-punto-flotante"><a class="docs-heading-anchor" href="#Números-de-punto-flotante">Números de punto flotante</a><a id="Números-de-punto-flotante-1"></a><a class="docs-heading-anchor-permalink" href="#Números-de-punto-flotante" title="Permalink"></a></h2><p>El conjunto de los números reales <span>$\mathbb{R}$</span> es infinito en dos sentidos: no es acotado y es contínuo. En computación numérica, reemplazamos <span>$\mathbb{R}$</span> por el conjunto de números de punto flotante <span>$\mathbb{F}$</span>, cuyos elementos son el cero y los números de la forma:</p><p class="math-container">\[\pm (1 + f) \times 2^e\]</p><p>donde <span>$e$</span> es el exponente y <span>$1+f$</span> es la mantisa, definda como</p><p class="math-container">\[f = \sum_{i=1}^d b_i 2^{-i}, \ b_i \in \left\{ 0,1 \right\}\]</p><p>con <span>$d$</span> un número entero fijo. Por lo tanto, <span>$f\in \left[0,1 \right)$</span> y <span>$(1+f)\in \left[1,2 \right)$</span>. Notar que:</p><p class="math-container">\[f = 2^{-d}\sum_{i=1}^d b_i 2^{d-i} = 2^{-d} z\]</p><p>con <span>$z\in \{ 0,1,\dots,2^d-1 \}$</span>. Por lo tanto, el conjunto <span>$\mathbb{F}$</span> contiene <span>$2^d$</span> números equiespaciados por <span>$2^{e-d}$</span>, cuyo primer elemento es <span>$2^e$</span> y el último es <span>$2^{e+1}-2^{-d}$</span>.</p><p>El elemento de <span>$\mathbb{F}$</span> es 1 y el siguiente es <span>$1+2^{-d}$</span> (para <span>$e=0$</span>) y, por lo tanto, la precisión de máquina o &quot;machine epsilon&quot; se define como <span>$\varepsilon_{mach}=2^{-d}$</span>.</p><p>La función de redondeo <span>$\mathbf{fl}$</span> mapea cada <span>$x\in\mathbb{R}$</span> al elemento <span>$\mathbf{fl}(x)\in\mathbb{F}$</span> más cercano. Si <span>$x$</span> es positivo, sabemos que <span>$x\in \left[ 2^e, 2^{e+1} \right)$</span> para algún <span>$e$</span>. Por lo tanto, <span>$| \mathbf{fl}(x) - x | \leq \frac{1}{2}(2^{e-d})$</span> y el error relativo (relative accuracy) de la función de redondeo está acotado por:</p><p class="math-container">\[\dfrac{| \mathbf{fl}(x) - x |}{| x |} \leq \frac{1}{2}\varepsilon_{mach}\]</p><p>o, lo que es equivalente:</p><p class="math-container">\[\mathbf{fl}(x) = x (1+\varepsilon) \mathrm{,~para~algún~} |\varepsilon|\leq \frac{1}{2}\varepsilon_{mach}\]</p><p>Por otro lado, la precisión (precision) de un número de punto flotante es siempre <span>$d$</span> dígitos binarios.</p><p>Según el estándar <em>IEEE 754</em>, se define single (double) precision para <span>$d=23$</span> (<span>$52$</span>) dígitos binarios para la parte fraccional <span>$f$</span>. En double precision <span>$\varepsilon_{mach}=2^{-52}\approx 2.2\times 10^{-16}$</span>.</p><p>Doble precisión corresponde a 64 bits binarios para representar un número: 52 bits para la mantisa (<span>$1+f$</span>), 1 bit para el signo y 11 bits para el exponente <span>$e$</span>. En este caso, el exponente <span>$e$</span> puede variar de <span>$2^0=1$</span> a <span>$2^11=2048$</span>. Como <span>$e$</span> puede valer <span>$0$</span>, los valores posibles de <span>$e$</span> son de <span>$0$</span> a <span>$2047$</span>, donde el <span>$1023$</span> representa el cero. Por lo tanto <span>$e=-1023$</span> cuando todos los bits son 0 y <span>$e=1024$</span> cuando todos los bits son 1. Sin embargo, estos extremos son reservados para números especiales (<span>$NaN$</span> y <span>$\pm \infty$</span>), se tiene que <span>$-1022\leq e \leq 1023$</span>.</p><pre><code class="language-julia hljs">@show typeof(1)
x = 1.0
@show typeof(x)
@show bitstring(x)
@show sign(x)
@show eps(); # machine epsilon
@show floatmin() floatmax();</code></pre><h2 id="Aritmética-de-punto-flotante"><a class="docs-heading-anchor" href="#Aritmética-de-punto-flotante">Aritmética de punto flotante</a><a id="Aritmética-de-punto-flotante-1"></a><a class="docs-heading-anchor-permalink" href="#Aritmética-de-punto-flotante" title="Permalink"></a></h2><p>Compare:</p><pre><code class="language-julia hljs">εₘ = eps()/2
(1.0 + ε) - 1.0</code></pre><p>con:</p><pre><code class="language-julia hljs">1.0 + (ε - 1.0)</code></pre><p>Las operaciones aritméticas en computadoras, son operaciones que se aplican a números de punto flotante y dan como resultado números de punto flotante. Cada operación matemática sobre números reales (suma, resta, multiplicación, división, raíz cuadrada, etc) tienen su análogo de máquina. Las operaciones elementales de máquina dan como resultado números de punto flotante cuyo error relativo está acotado por <span>$\varepsilon_{mach}$</span>. Por ejemplo, dados <span>$x, \ y \in \mathbb{F}$</span>, el error de la suma de máquina <span>$\oplus$</span> está acotado por:</p><p class="math-container">\[\dfrac{|(x\oplus y)- (x+y)|}{|x+y|}\leq \varepsilon_{mach}\]</p><p>Por lo tanto, el error de las operaciones de máquina es prácticamente el mismo que el de la propia representación de los números de punto flotante.</p><p>Volviendo al ejemplo planteado, vemos que <code>(1.0 + ε) - 1.0</code> da <span>$0$</span> miesntras que <code>1.0 + (ε - 1.0)</code> da <code>ε</code> (resultado exacto). Para entender este comportamiento, se debe notar que entre <span>$1$</span> y <span>$1+\varepsilon_{mach}/2$</span> no hay números de punto flotante, pues, en el intervalo <span>$[1,2)$</span>, el menor espaciamiento es <span>$\varepsilon_{mach}$</span> (correspondiente a <span>$e=0$</span>), por lo que la diferencia da <span>$0$</span>. Por otro lado, el espacio entre números de punto flotante en el intervalo <span>$[1/2,1)$</span> es <span>$\varepsilon_{mach}/2$</span> (para <span>$e=-1$</span>), por lo tanto <span>$1-\varepsilon_{mach}/2$</span> (y, por lo tanto, también su opuesto) se representa de manera exacta. Es por eso que en este último caso, el resultado <code>1.0 + (ε - 1.0)</code> es el exacto (<span>$\varepsilon_{mach}/2$</span>).</p><h2 id="Número-de-condición"><a class="docs-heading-anchor" href="#Número-de-condición">Número de condición</a><a id="Número-de-condición-1"></a><a class="docs-heading-anchor-permalink" href="#Número-de-condición" title="Permalink"></a></h2><p>Sea <span>$\tilde{x}=\mathbf{fl}(x)=x(1+\varepsilon)$</span>, para algún <span>$|\varepsilon|\leq \varepsilon_{mach}/2$</span>. Dada una función <span>$f:\mathbb{R}\to\mathbb{R}$</span>, calculamos la tasa de cambio relativo del resultado y de los datos como:</p><p class="math-container">\[\dfrac{\dfrac{|f(x)-f(\tilde{x})|}{|f(x)|}}{\dfrac{|x-\tilde{x}|}{|x|}}=\dfrac{|f(x)-f(x(1+\varepsilon))|}{| \varepsilon f(x) |}\]</p><p>Se define el condition number relativo para el problema <span>$f(x)$</span>, (<span>$\kappa_f (x)$</span>) tomando el límite para <span>$\varepsilon_{mach}\to 0$</span>, es decir, para el caso ideal de una computadora perfecta:</p><p class="math-container">\[\kappa_f (x) = \lim_{\varepsilon\to 0} \dfrac{|f(x)-f(x(1+\varepsilon))|}{| \varepsilon f(x) |}=\left| \dfrac{x f^\prime(x)}{f(x)} \right|\]</p><p>El problema de <span>$f(x)$</span> es mal-condicionado (<em>ill-conditioned</em>) cuando <span>$\kappa_f (x)$</span> es grande, ya que pequeñas perturbaciones del dato <span>$x$</span> provoca grandes cambios relativos del resultado <span>$f(x)$</span>. En particular, <span>$\kappa_f (x)$</span> grandes son una señal de que el error en el cálculo de la función <span>$f(x)$</span> no se mantendrá comparable con el error de redondeo de <span>$x$</span>.</p><h2 id="El-problema-de-k-bandits"><a class="docs-heading-anchor" href="#El-problema-de-k-bandits">El problema de k-bandits</a><a id="El-problema-de-k-bandits-1"></a><a class="docs-heading-anchor-permalink" href="#El-problema-de-k-bandits" title="Permalink"></a></h2><h2 id="Evaluacion-de-polinomios"><a class="docs-heading-anchor" href="#Evaluacion-de-polinomios">Evaluacion de polinomios</a><a id="Evaluacion-de-polinomios-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluacion-de-polinomios" title="Permalink"></a></h2><p>Como ejemplos consideremos el polinomio univariado <span>$P_k \in \mathbb{R}[x]$</span> dado por</p><p class="math-container">\[P_k(x) := \sum_{k=0}^n \dfrac{x^k}{k!} = 1 + x + \frac{x^2}{2!} + \ldots + \frac{x^k}{k!}.\]</p><p>(a) Implementar una funcion <code>evaluar(x)</code> que evalua el polinomio <span>$P_k$</span> en el valor <span>$x$</span>.</p><p>(b) ¿Cuantas multiplicaciones y cuantas divisiones utilizó en la parte anterior, para un valor de <span>$k$</span> dado? Chequear (o revisar la implementación si no se verifica) que no se utilizan más de <span>$2k$</span> multiplicaciones ni más de <span>$k$</span> divisiones.</p><p>(c) Implementar la evaluación utilizando el <a href="https://es.wikipedia.org/wiki/Algoritmo_de_Horner">algoritmo de Horner</a>. Revisar el resultado de la parte anterior con el nuevo algoritmo.  </p><h2 id="Iteración-de-punto-fijo"><a class="docs-heading-anchor" href="#Iteración-de-punto-fijo">Iteración de punto fijo</a><a id="Iteración-de-punto-fijo-1"></a><a class="docs-heading-anchor-permalink" href="#Iteración-de-punto-fijo" title="Permalink"></a></h2><p><a href="https://fncbook.github.io/v1.0/nonlineqn/demos/fp-spiral.html">Fixed point iteration</a></p><h2 id="Aritmética-de-intervalos"><a class="docs-heading-anchor" href="#Aritmética-de-intervalos">Aritmética de intervalos</a><a id="Aritmética-de-intervalos-1"></a><a class="docs-heading-anchor-permalink" href="#Aritmética-de-intervalos" title="Permalink"></a></h2><h2 id="Descenso-por-gradiente"><a class="docs-heading-anchor" href="#Descenso-por-gradiente">Descenso por gradiente</a><a id="Descenso-por-gradiente-1"></a><a class="docs-heading-anchor-permalink" href="#Descenso-por-gradiente" title="Permalink"></a></h2><h2 id="Referencias"><a class="docs-heading-anchor" href="#Referencias">Referencias</a><a id="Referencias-1"></a><a class="docs-heading-anchor-permalink" href="#Referencias" title="Permalink"></a></h2><hr/><h2 id="Entregable-3"><a class="docs-heading-anchor" href="#Entregable-3">Entregable 3</a><a id="Entregable-3-1"></a><a class="docs-heading-anchor-permalink" href="#Entregable-3" title="Permalink"></a></h2><div class="admonition is-warning"><header class="admonition-header">Formato de entrega</header><div class="admonition-body"><p>El formato de entrega es análogo al utilizado en los entregables anteriores, ver <a href="https://mforets.github.io/computacion-cientifica-en-julia/dev/Herramientas/Entorno_de_desarrollo/#.2.-Creaci%C3%B3n-de-un-repositorio">Ejercicio 1.2 Creación de un repositorio</a>. En particular, todos los ejercicios entregados deben ser parte de un único módulo llamado <code>Entregable_3</code> que define la constante CI asi como también exporta las funciones que se piden en cada ejercicio entregado. <strong>Importante:</strong> Además debe incluir los archivos de proyecto (<code>Project.toml</code> y <code>Manifest.toml</code>) en su entrega. </p></div></div><h4 id=".1.-Integración-de-Runge-Kutta"><a class="docs-heading-anchor" href="#.1.-Integración-de-Runge-Kutta">3.1. Integración de Runge-Kutta</a><a id=".1.-Integración-de-Runge-Kutta-1"></a><a class="docs-heading-anchor-permalink" href="#.1.-Integración-de-Runge-Kutta" title="Permalink"></a></h4><p>En este ejercicio trabajamos con ecuaciones diferenciales numéricamente. Sea <span>$x&#39; = f(x(t), t)$</span>, <span>$x \in \mathbb{R}^n$</span>, un sistema de ecuaciones diferenciales ordinarias de primer orden en <span>$n \geq 1$</span> variables. Dentro de la gran variedad de enfoques para integrar numéricamente dichos sistemas se encuentra la familia de métodos de <a href="https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods">Runge-Kutta</a>. Nos concentramos en el método RK4 (cuarto orden) que se describe a continuación. En dicho método, dado un paso temporal <span>$h &gt; 0$</span> y un estado inicial <span>$x_0$</span> se calcula, para cada <span>$k = 0, 1,\ldots, N$</span>, una secuencia de valores <span>$x_1, x_2, \ldots, x_N$</span> mediante la siguiente fórmula explícita:</p><p class="math-container">\[x_{k+1} = x_k + h\sum_{k=1}^s b_k w_k,\]</p><p>Para el esquema que nos interesa utilizamos <span>$s = 4$</span> y los coeficientes <span>$b_i$</span> resultan ser <span>$(1/6, 2/6, 2/6, 1/6)$</span>. Los términos <span>$w_i$</span> resultan de evaluar el campo vectorial <span>$f$</span> en los siguientes puntos intermedios: <span>$w_1 = f(x, t)$</span>, <span>$w_2 = f(x + hw_1 / 2, t + h/2)$</span>, <span>$w_3 = f(x + hw_2 / 2, t + h/2)$</span> y <span>$w_4 = f(x + hw_3, t + h)$</span>.</p><p>Implementar una función <code>integrate(f::Function, alg::RK4, t0, T, x0)</code> que resuelve el problema de valores iniciales <span>$x&#39; = f(x(t), t)$</span>, <span>$x(0) = x_0$</span>, en el intervalo de tiempo entre <span>$t_0$</span> y <span>$T$</span>. Aquí <code>RK4</code> es un struct asociado al algoritmo y que debe almacenar el paso <span>$h$</span> (sin valor por defecto). La función <code>integrate</code> debe devolver un vector con el resultado de la integración.</p><p>Como caso de ejemplo se considerará la integración de las ecuaciones de <a href="https://es.wikipedia.org/wiki/Ecuaciones_Lotka%E2%80%93Volterra">Lotka-Volterra</a>:</p><pre><code class="language-julia hljs">function lotkavolterra(x, t)
    α, β, γ, δ = 1.5, 1., 3., 1.
    [α * x[1] - β * x[1] * x[2], δ * x[1] * x[2] - γ * x[2]]
end</code></pre><p>entendiéndose que el siguiente comando debe integrar dicho sistema entre <span>$t = 0$</span> y <span>$t = 1.0$</span> con paso temporal <span>$h = 0.01$</span> y condición inicial <span>$x_0 = [1, 1]$</span>:</p><pre><code class="language-julia hljs">julia&gt; integrate(lotkavolterra, RK4(h=0.01), 0.0, 1.0, ones(2))</code></pre><h4 id=".2.-Evaluación-de-polinomios-por-el-método-de-Bernstein"><a class="docs-heading-anchor" href="#.2.-Evaluación-de-polinomios-por-el-método-de-Bernstein">3.2. Evaluación de polinomios por el método de Bernstein</a><a id=".2.-Evaluación-de-polinomios-por-el-método-de-Bernstein-1"></a><a class="docs-heading-anchor-permalink" href="#.2.-Evaluación-de-polinomios-por-el-método-de-Bernstein" title="Permalink"></a></h4><p>En este ejercicio trabajamos con polinomios univariados <span>$p : \mathbb{R} \to \mathbb{R}$</span>, cuyos coeficientes en la base de potencias notamos <span>$\{a_i\}_{i=0}^l$</span> siendo <span>$l \in \mathbb{N}$</span> el <em>grado</em> del polinomio (<span>$a_l \neq 0$</span>). Tiene así a lo sumo <span>$l+1$</span> términos (monomios) no nulos y escribimos:</p><p class="math-container">\[p(x) = a_0 + a_1 x + \ldots + a_l x^l.\]</p><p>Para trabajar con polinomios univariados en Julia utilizaremos <a href="https://github.com/JuliaMath/Polynomials.jl">Polynomials.jl</a>. Por ejemplo, sea</p><p class="math-container">\[p(x) = 3x^2 - 2x + 1.\]</p><p>Podemos definirlo como un <code>Polynomials.Polynomial</code> así:</p><pre><code class="language-julia hljs">julia&gt; using Polynomials

julia&gt; p = Polynomial([1, -2, 3])
Polynomial(1 - 2*x + 3*x^2)</code></pre><p>Nótese que el órden más bajo se ingresa primero. Consultar la documentación de <a href="https://juliamath.github.io/Polynomials.jl/stable/">Polynomials.jl</a> por más casos de uso.</p><p>El método llamado <em>expansion de Bernstein</em> permite, entre otras cosas, calcular extremos (máximos y mínimos) de polinomios en un dominio dado, de manera aproximada pero rápida. Dicho método también aplica a polinomios multivariados, pero dejaremos esa generalización para un entregable futuro. Como referencia, tanto para el caso univariado como para el multivariado, ver <a href="https://d-nb.info/1028327854/34">Enclosure Methods for Systems of Polynomial Equations and Inequalities</a> de A. P. Smith (2012).</p><p>El primer paso en este ejercicio consiste en implementar una función</p><pre><code class="language-julia hljs">bernstein_basis(l::Int, i::Int)::Function</code></pre><p>que devuelve el polinomio de Bernstein <span>$i$</span>-ésimo de grado <span>$l$</span>, definido mediante la fórmula</p><p class="math-container">\[B_i^l(x) = \binom{l}{i}x^i (1 - x)^{l-i},\qquad i = 0, \ldots, l.\]</p><p>Se adopta la convención de que <span>$B_i^l(x) = 0$</span> para todo <span>$x$</span> si <span>$i &lt; 0$</span> o si <span>$i &gt; l$</span>.</p><p>Por ejemplo, <span>$B^3_1(x) = 3x^3 - 6x^2 + 3x$</span>:</p><pre><code class="language-julia hljs">julia&gt; p = bernstein_basis(3, 1)
#1 (generic function with 1 method)

julia&gt; p_test = Polynomial([0, 3, -6, 3])
Polynomial(3*x - 6*x^2 + 3*x^3)

julia&gt; sum(abs(p(x) - p_test(x)) for x in rand(1_000))
5.703991186984617e-14</code></pre><p>Se recomienda corroborar su implementación con los gráficos de la Figura 3.1 de la citada tesis.</p><p>Dado un polinomio en la base de potencias</p><p class="math-container">\[p(x) = \sum_{i=0}^l a_i x^i,\]</p><p>su expresión en la base de Bernstein de grado <span>$l$</span> en el dominio unitario <span>$X = [0, 1]$</span> es:</p><p class="math-container">\[p(x) = \sum_{i=0}^l b_i B_i^l(x),\]</p><p>con <span>$l + 1$</span> coeficientes <span>$\{b_i\}$</span> a determinar. Por ejemplo:</p><p class="math-container">\[p(x) = -5x^2 + 2x + 3 = 3(1 - 2x+x^2) + 4(2x - 2x^2) = 3 B_0^2(x) + 4B_1^2(x).\]</p><p>Así, en este ejemplo los coeficientes en la base de potencias son <span>$(a_0, a_1, a_2) = (3, 2, -5)$</span> mientras que los coeficientes en la base de Bernstein de grado <span>$l = 2$</span> son <span>$(b_0, b_1, b_2) = (3, 4, 0)$</span>.</p><p>Implementar una función</p><pre><code class="language-julia hljs">bernstein_coefficients(pol::Polynomial)::Vector</code></pre><p>que permite convertir de la base de potencias a la base de Bernstein. La conversión se puede lograr mediante la siguiente fórmula (ver Teorema (3.2) de la citada tesis para la demostración):</p><p class="math-container">\[b_i = \sum_{j = 0}^i \dfrac{\binom{i}{j}}{\binom{l}{j}}a_j,\qquad 0 \leq i \leq l.\]</p><p>En el ejemplo anterior,</p><pre><code class="language-julia hljs">julia&gt; p = Polynomial([3, 2, -5])
Polynomial(3 + 2*x - 5*x^2)

julia&gt; bernstein_coefficients(p)
[3, 4, 0]</code></pre><p>Cuando el dominio de interés no es el intervalo unitario, se requiere utilizar una fórmula de transformacion generalizada. Sea <span>$X = [\underline{x}, \bar{x}]$</span> un dominio (intervalo) arbitrario, <span>$\underline{x} &lt;  \bar{x}$</span>. Implementar una función</p><pre><code class="language-julia hljs">bernstein_coefficients(pol::Polynomial, X::Tuple{Number,Number})::Vector</code></pre><p>que recibe un polinomio y devuelve en un vector los <span>$l+1$</span> coeficientes de Bernstein <span>$\{b_i\}$</span> asociados de grado <span>$l$</span> en <span>$X$</span> (representado como una tupla de números). Para ello se utilizará el siguiente resultado (ver ecuación (3.13) de la citada tesis):</p><p class="math-container">\[b_i = \sum_{j=0}^i \dfrac{\binom{i}{j}}{\binom{l}{j}}(\bar{x} - \underline{x})^j \sum_{k=j}^l \binom{k}{j}\underline{x}^{k-j}a_k,\qquad 0 \leq i \leq l.\]</p><p>Una de las propiedades más interesantes de la expansión de Bernstein es que los coeficientes de la expansión contienen información sobre el <em>rango</em> del polinomio en el dominio <span>$X$</span> dado, resultado que se conoce como <em>Bernstein enclosure</em>. Concretamente,</p><p class="math-container">\[\min_{i} \{ b_i \} \leq p(x) \leq \max_{i} \{b_i\},\qquad x \in X. \]</p><p>Implementar una función</p><pre><code class="language-julia hljs">bernstein_enclosure(pol::Polynomial, X::Tuple{Number,Number})::Tuple{Number,Number}</code></pre><p>que devuelve una tupla con la estimación del rango de <span>$p(x)$</span> utilizando el método de Bernstein.</p><p>En síntesis, este ejercicio requiere implementar las siguientes funciones:</p><pre><code class="language-julia hljs">bernstein_basis(l::Int, i::Int)::Function
bernstein_coefficients(pol::Polynomial)::Vector
bernstein_coefficients(pol::Polynomial, X::Tuple{Number,Number})::Vector
bernstein_enclosure(pol::Polynomial, X::Tuple{Number,Number})::Tuple{Number,Number}</code></pre><hr/><h2 id="Entregable-4"><a class="docs-heading-anchor" href="#Entregable-4">Entregable 4</a><a id="Entregable-4-1"></a><a class="docs-heading-anchor-permalink" href="#Entregable-4" title="Permalink"></a></h2><div class="admonition is-warning"><header class="admonition-header">Formato de entrega</header><div class="admonition-body"><p>El formato de entrega es análogo al utilizado en los entregables anteriores, ver <a href="https://mforets.github.io/computacion-cientifica-en-julia/dev/Herramientas/Entorno_de_desarrollo/#.2.-Creaci%C3%B3n-de-un-repositorio">Ejercicio 1.2 Creación de un repositorio</a>. En particular, todos los ejercicios entregados deben ser parte de un único módulo llamado <code>Entregable_4</code> que define la constante CI asi como también exporta las funciones que se piden en cada ejercicio entregado. <strong>Importante:</strong> Además debe incluir los archivos de proyecto (<code>Project.toml</code> y <code>Manifest.toml</code>) en su entrega. </p></div></div><h4 id=".1.-Método-UCB-para-el-problema-de-k-bandits"><a class="docs-heading-anchor" href="#.1.-Método-UCB-para-el-problema-de-k-bandits">4.1. Método UCB para el problema de k-bandits</a><a id=".1.-Método-UCB-para-el-problema-de-k-bandits-1"></a><a class="docs-heading-anchor-permalink" href="#.1.-Método-UCB-para-el-problema-de-k-bandits" title="Permalink"></a></h4><p>En este ejercicio revisitamos el problema de k-bandits trabajado en clase. Se implementará el algoritmo llamado upper-confidence-bound (UCB) que se describe a continuación. Sea <span>$A_t$</span> la acción seleccionada en el tiempo <span>$t$</span> para <span>$t = 1, \ldots, N$</span> pasos de tiempo, y sea <span>$Q_t(a)$</span> el <em>promedio</em> de recompensas recibido de la acción <span>$a$</span> a tiempo <span>$t$</span>.</p><p>El algoritmo UCB utiliza la siguiente lógica:</p><p class="math-container">\[A_t := \argmax_{a} \left( Q_t(a) + c \sqrt{\dfrac{\ln t}{N_t(a)}} \right),\]</p><p>donde <span>$\ln t$</span> es el logaritmo (natural) del número de jugada actual, <span>$N_t(a)$</span> es el número de veces que la acción <span>$a$</span> ha sido seleccionada anteriormente a la jugada <span>$t$</span>-ésima, y la constante <span>$c &gt; 0$</span> es un parámetro del algoritmo que controla el grado de <em>exploración</em>. Si <span>$N_t(a)$</span> es igual a cero, se considera que <span>$a$</span> maximiza la expresión. Si hay más de un maximizador, se escoge uno de ellos al azar (de manera uniforme).</p><p>La idea del algoritmo es seleccionar aquellas acciones (&quot;palancas&quot;) de acuerdo a su potencial de ser óptimas, tomando en cuenta tanto el estimado del mejor valor actual, como también la incertidumbre asociada a dicha estimación.</p><p>Extender la función <code>simular</code> trabajada en clase agregando el método:</p><pre><code class="language-julia hljs">simular(J::Juego, alg::UCB; budget::Int = 1000)</code></pre><p>que implementa el algoritmo anterior. Se utilizará un struct <code>UCB</code> asociado al algoritmo que debe almacenar el parámetro de diseño, con un valor por defecto de <span>$c=2$</span>.</p><h4 id=".2.-Conjunto-alcanzable-mediante-simulaciones"><a class="docs-heading-anchor" href="#.2.-Conjunto-alcanzable-mediante-simulaciones">4.2. Conjunto alcanzable mediante simulaciones</a><a id=".2.-Conjunto-alcanzable-mediante-simulaciones-1"></a><a class="docs-heading-anchor-permalink" href="#.2.-Conjunto-alcanzable-mediante-simulaciones" title="Permalink"></a></h4><p>En este ejercicio construimos sobre el Ejercicio 3.1 combinando las simluaciones con <a href="https://en.wikipedia.org/wiki/Euclidean_space">conjuntos en espacios Euclídeos</a>. Se debe escribir una función <code>reachable_set(f::Function, ::RK4, t0, T, X0::Box)</code> que devuelve otro conjunto <span>$Y$</span> tal que <span>$Y$</span> es una estimación, obtenida mediante simulación numérica de los estados alcanzables en el tiempo <span>$T$</span>.</p><p>Independiente de la implementación de <code>Box</code> utilizada, ésta debe admitir un constructor con centro (vector) y radio (escalar), e.g. <code>Box([1.0, 1.0], 1.0)</code> que representa el conjunto <span>$\{x \in \mathbb{R}^2: \Vert x - c\Vert_\infty \leq 1 \}$</span> donde <span>$c$</span> es el centro (en el ejemplo, <span>$c = [1, 1]$</span>).</p><p>Para la estimación se utilizará el algoritmo RK4 y para el muestreo de <span>$X_0$</span> se utilizará una secuencia de Sobol, pudiéndose utilizar el paquete <a href="https://github.com/stevengj/Sobol.jl">Sobol.jl</a> para tal fin. La ventaja que tiene utilizar dichas secuencias es que generan una distribución que cubre &quot;cuasi-regularmente&quot; el conjunto de partida.</p><h4 id=".3.-Expansión-rápida-de-Bernstein-para-polinomios-univariados"><a class="docs-heading-anchor" href="#.3.-Expansión-rápida-de-Bernstein-para-polinomios-univariados">4.3. Expansión rápida de Bernstein para polinomios univariados</a><a id=".3.-Expansión-rápida-de-Bernstein-para-polinomios-univariados-1"></a><a class="docs-heading-anchor-permalink" href="#.3.-Expansión-rápida-de-Bernstein-para-polinomios-univariados" title="Permalink"></a></h4><p>En este ejercicio revisitamos la expansión de Bernstein para polinomios univariados del Ejercicio 3.2. Se debe implementar una versión optimizada utilizando el resultado de la Sección 9.2.1 de la tesis de A. P. Smith. Se deben implementar los siguientes métodos:</p><pre><code class="language-julia hljs">bernstein_coefficients(pol::Polynomial, alg::Algorithm=Fast())::Vector
bernstein_coefficients(pol::Polynomial, X::Tuple{Number,Number}, alg::Algorithm=Fast())::Vector
bernstein_enclosure(pol::Polynomial, X::Tuple{Number,Number}, alg::Algorithm=Fast())::Tuple{Number,Number}</code></pre><p>siendo <code>Fast</code> un struct que representa el nuevo algoritmo y <code>Naive</code> un struct que representa el algoritmo anterior. Comparar el tiempo de ejecución y el número de alocaciones de cada algoritmo utilizando <a href="https://github.com/JuliaCI/BenchmarkTools.jl"><code>BenchmarkTools.jl</code></a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Primeros_pasos_en_Julia/">« Primeros pasos en Julia</a><a class="docs-footer-nextpage" href="../Computacion_simbolica/">Computación simbólica »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 23 March 2023 23:39">Thursday 23 March 2023</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
