<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Computación simbólica · Computación Científica en Julia</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/aligned.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Computación Científica en Julia</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Generalidades</a></li><li><a class="tocitem" href="../../proyectos/">Proyectos</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Entregables</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Entregables/Entregable1/">Entregable 1</a></li><li><a class="tocitem" href="../../Entregables/Entregable2/">Entregable 2</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">Herramientas básicas</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../Alcance_del_curso/">Alcance del curso</a></li><li><a class="tocitem" href="../Entorno_de_desarrollo/">Entorno de desarrollo</a></li><li><a class="tocitem" href="../Primeros_pasos_en_Julia/">Primeros pasos en Julia</a></li><li><a class="tocitem" href="../Computacion_numerica/">Computación numérica</a></li><li class="is-active"><a class="tocitem" href>Computación simbólica</a><ul class="internal"><li><a class="tocitem" href="#Expresiones-simbólicas"><span>Expresiones simbólicas</span></a></li><li><a class="tocitem" href="#Iteradores"><span>Iteradores</span></a></li><li><a class="tocitem" href="#Diferenciación-automática"><span>Diferenciación automática</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Fundamentos de Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Fundamentos/Tipos de datos basicos/">Tipos de datos básicos</a></li><li><a class="tocitem" href="../../Fundamentos/Reglas de alcance/">Reglas de alcance</a></li><li><a class="tocitem" href="../../Fundamentos/Arreglos/">Arreglos</a></li><li><a class="tocitem" href="../../Fundamentos/Gestor de paquetes/">Gestor de paquetes</a></li><li><a class="tocitem" href="../../Fundamentos/Estructuras de datos/">Estructuras de datos</a></li><li><a class="tocitem" href="../../Fundamentos/Funciones/">Funciones</a></li><li><a class="tocitem" href="../../Fundamentos/Mecanismos de evaluacion/">Mecanismos de evaluacion</a></li><li><a class="tocitem" href="../../Fundamentos/Metaprogramacion/">Metaprogramación</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Patrones de diseño</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Patrones/paquetes/">Generación de paquetes</a></li><li><a class="tocitem" href="../../Patrones/reutilizacion/">Patrones para reutilización de código</a></li><li><a class="tocitem" href="../../Patrones/docs/">Documentación de código</a></li><li><a class="tocitem" href="../../Patrones/performance/">Patrones para performance</a></li><li><a class="tocitem" href="../../Patrones/debugging/">Patrones de robustez</a></li><li><a class="tocitem" href="../../Patrones/programacion_generica/">Programación genérica</a></li><li><a class="tocitem" href="../../Patrones/programacion_paralela/">Programación paralela</a></li><li><a class="tocitem" href="../../Patrones/antipatrones/">Anti-patrones</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Librerías</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Ecosistema/graficos_pub/">Gráficos para publicaciones</a></li><li><a class="tocitem" href="../../Ecosistema/jump/">Optimización</a></li><li><a class="tocitem" href="../../Ecosistema/sciml/">Modelado y simulaciones numericas</a></li><li><a class="tocitem" href="../../Ecosistema/flux/">Aprendizaje automático</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Herramientas básicas</a></li><li class="is-active"><a href>Computación simbólica</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Computación simbólica</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mforets/computacion-cientifica-en-julia/blob/master/docs/src/Herramientas/Computacion_simbolica.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Computación-simbólica"><a class="docs-heading-anchor" href="#Computación-simbólica">Computación simbólica</a><a id="Computación-simbólica-1"></a><a class="docs-heading-anchor-permalink" href="#Computación-simbólica" title="Permalink"></a></h1><h2 id="Expresiones-simbólicas"><a class="docs-heading-anchor" href="#Expresiones-simbólicas">Expresiones simbólicas</a><a id="Expresiones-simbólicas-1"></a><a class="docs-heading-anchor-permalink" href="#Expresiones-simbólicas" title="Permalink"></a></h2><h2 id="Iteradores"><a class="docs-heading-anchor" href="#Iteradores">Iteradores</a><a id="Iteradores-1"></a><a class="docs-heading-anchor-permalink" href="#Iteradores" title="Permalink"></a></h2><h2 id="Diferenciación-automática"><a class="docs-heading-anchor" href="#Diferenciación-automática">Diferenciación automática</a><a id="Diferenciación-automática-1"></a><a class="docs-heading-anchor-permalink" href="#Diferenciación-automática" title="Permalink"></a></h2><p>Las técnicas de diferenciación automática (AD) son algoritmos para evaluar numéricamente las derivadas de funciones especificadas por un programa computacional. La AD explota el hecho de que, independientemente de su complejidad, todo programa computacional ejecuta una secuencia de opraciones matemáticas elementales (suma, resta, multiplicación, división, etc.) y funciones elementales (<span>$\exp$</span>, <span>$\log$</span>, <span>$\sin$</span>, <span>$\cos$</span>, etc.). La AD aplica repetidamente la regla de la cadena para calcular, de forma automática, la derivada, de cualquier orden, de estas operaciones y funciones elementales.</p><p>La AD es diferente a la diferenciación simbólica y a la diferenciación numérica. La diferenciación simbólica consiste en transformar el programa computacional en una expresión matemática. La diferenciación numérica, como ser diferencias finitas, requiere de una discretización, que conlleva un error de truncamiento y de cancelación. Además, estos dos últimos pueden ser ineficientes cuando el número de inputs es alto, y requiere de la aplicación de algoritmos de optimización basados en el gradiente.</p><p>La AD se basa en la regla de la cadena:</p><p class="math-container">\[
\dfrac{d}{dx} f(g(x)) = \dfrac{d}{dx} (f \circ g) = \dfrac{df}{dg}\dfrac{dg}{dx}
$

Consideremos la función $f(a,b) = \ln(ab+\max(a, 2))\]</p><p>.</p><p>La derivada de <span>$f$</span> respecto de <span>$a$</span> resulta:</p><p class="math-container">\[\dfrac{\partial f}{\partial a} = \dfrac{1}{ab+\max(a, 2)}[b + (2&lt;a)]\]</p><p>.</p><p>El proceso detrás de este cálculo se puede automatizar por medio de un grafo computacional. Estos grafos representan una funcion donde los nodos son operaciones y las aristas son relaciones input-output. Las hojas del grafo son las variables input y las constantes involucradas, mientras que los nodos terminales son los otuput de la función.</p><p><img src="../Figures/comp_graph.png" alt="Grafo computacional"/></p><p>Existen dos métodos para derivar <span>$f$</span> automáticamente usando su grafo computacional: la acumulación hacia adelante, que atraviesa el grafo en la dirección inputs<span>$\to$</span>outputs usando números duales, y la acumlación reversa, que requiere de una recorrida del grafo hacia atrás.</p><h3 id="Acumulación-hacia-adelante-(*Forward-accumulation*)"><a class="docs-heading-anchor" href="#Acumulación-hacia-adelante-(*Forward-accumulation*)">Acumulación hacia adelante (<em>Forward accumulation</em>)</a><a id="Acumulación-hacia-adelante-(*Forward-accumulation*)-1"></a><a class="docs-heading-anchor-permalink" href="#Acumulación-hacia-adelante-(*Forward-accumulation*)" title="Permalink"></a></h3><p>Este método usa una única pasada del grafo computacional y es equivalente a expandir iterativamente la regla de la cadena de las operaciones internas. Cuando <span>$f$</span> depende de varias variables, se debe hacer una recorrida del grafo por cada derivada parcial. Por ejemplo:</p><p class="math-container">\[\dfrac{df}{da} = \dfrac{df}{d c_4 } \dfrac{d c_4 }{da}=\dfrac{df}{dc_4}\left(\dfrac{dc_4}{dc_3}\dfrac{dc_3}{da}\right) = \dfrac{df}{dc_4}\left(\dfrac{dc_4}{dc_3}\left(\dfrac{dc_3}{dc_2}\dfrac{dc_2}{da}+\dfrac{dc_3}{dc_1}\dfrac{dc_1}{da}\right)\right)\]</p><p>En color azul se representan las evaluaciones de las variables sucesivas, mientras en color rojo las derivadas respecto de <span>$a$</span>. El procedimiento es el siguiente:</p><ol><li>Comenzamos desde los nodos de inputs y de valores constantes. Allí calculamos su valor y el valor de la derivada respecto de <span>$a$</span>. Por ejemplo, para <span>$a=3$</span>, <span>$b=2$</span>, este paso sería:</li></ol><p><img src="../Figures/fwd_graph_1.png" alt="Grafo computacional: Forward accumulation"/></p><ol><li>Luego, procedemos a recorrer el árbol, nodo por nodo, calculando el valor de la variable en el nodo y de la derivada. Para ello, debemos escoger el nodo a recorrer en cada paso de manera que ya conozcamos o hayamos calculado los inputs. Así obtenemos el siguiente grafo:</li></ol><p><img src="../Figures/fwd_graph.png" alt="Grafo computacional: Forward accumulation"/></p><p>Este cálculo puede ser automatizado en una computadora si utilizamos los &quot;números duales&quot;, que permiten calcular a la vez el valor de la función y de su derivada en cada nodo con una sola operación. Los números duales se escriben de manera similar a los complejos, <span>$a+b \epsilon$</span>, pero tal que <span>$\epsilon^2=0$</span>. Por lo tanto:</p><p class="math-container">\[(a+b \epsilon) + (c+d \epsilon) = (a+c)+ (b+d) \epsilon\]</p><p class="math-container">\[(a+b \epsilon) \times (c+d \epsilon) = (ab)+ (ad+bc)\epsilon\]</p><p>Si escribimos la expansión de Taylor de <span>$f(x)$</span> en torno a <span>$a$</span>, <span>$f(x)=\displaystyle \sum_{k=0}^{\infty}\dfrac{f^{(k)}(a)}{k!}(x-a)^k$</span>, se obtiene que:</p><p class="math-container">\[f(a+b\epsilon)=f(a)+b f^{\prime}(a)\epsilon\]</p><p>Por lo tanto, si pasamos un número dual a <span>$f$</span>, obtenemos <span>$f$</span> y <span>$f^{\prime}$</span> en una sola evaluación.</p><p>Con este procedimiento, para calcular el gradiente de una función que depende de <span>$n$</span> variables, debemos recorrer <span>$n$</span> veces el grafo. Por esto, la acumulación hacia adelante es recomendada cuando el número de outputs es mucho mayor que el número de inputs.</p><p>Ejemplo: <span>$f(x_1,x_2)=x_1 x_2 + \sin x_1$</span></p><p><img src="../Figures/Wiki_ForwardAccumulationAutomaticDifferentiation.png" alt="Grafo computacional: Forward accumulation (Wiki)"/></p><p>Implementación en Julia de la diferenciación automática de <span>$f(a,b) = \ln(ab+\max(a, 2))$</span> para <span>$a=3$</span>, <span>$b=2$</span> con el método de acumulación hacia adelante:</p><p>1- Definimos el <code>struct</code> para representar los números duales</p><pre><code class="language-julia hljs">struct Dual
	v
	∂
end

Base.:+(a::Dual, b::Dual) = Dual(a.v + b.v, a.∂ + b.∂)

Base.:*(a::Dual, b::Dual) = Dual(a.v * b.v, a.v*b.∂ + b.v*a.∂)

Base.log(a::Dual) = Dual(log(a.v), a.∂/a.v)

function Base.max(a::Dual, b::Dual)
	v = max(a.v, b.v)
	∂ = a.v &gt; b.v ? a.∂ : a.v &lt; b.v ? b.∂ : NaN
	return Dual(v, ∂)
end

function Base.max(a::Dual, b::Int)
	v = max(a.v, b)
	∂ = a.v &gt; b ? a.∂ : a.v &lt; b ? 0 : NaN
	return Dual(v, ∂)
end</code></pre><p>2- Computamos el gradiente en <span>$a=3$</span>, <span>$b=2$</span> con el paquete <code>ForwardDiff.jl</code>:</p><pre><code class="language-julia hljs">using ForwardDiff

a = ForwardDiff.Dual(3,1);
b = ForwardDiff.Dual(2,0);

log(a*b + max(a,2)) # Forward Differentitaion</code></pre><h3 id="Acumulación-reversa-(*Reverse-accumulation*)"><a class="docs-heading-anchor" href="#Acumulación-reversa-(*Reverse-accumulation*)">Acumulación reversa (<em>Reverse accumulation</em>)</a><a id="Acumulación-reversa-(*Reverse-accumulation*)-1"></a><a class="docs-heading-anchor-permalink" href="#Acumulación-reversa-(*Reverse-accumulation*)" title="Permalink"></a></h3><p>La acumulación reversa requiere de una sola corrida para calcular el gradiente de <span>$f$</span>, independientemente de la cantidad de variables de las que depende, pero requiere de dos recorridas del grafo: una pasada hacia adelante (<em>forward pass</em>), en la que se computan todos los valores intermedios necesarios, y otra pasada hacia atrás (<em>backward pass</em>), que es la que computa el gradiente.</p><p>El procedimiento consiste en explotar la relación:</p><p class="math-container">\[\displaystyle \bar{c_i} = \dfrac{\partial f}{\partial c_i} = \sum_{j: \ j \mathrm{ \ es \ hijo \ de \ } i} \bar{c_j} \dfrac{\partial c_j}{\partial c_i}\]</p><p>,</p><p>donde <span>$\bar{c_i}$</span> es el &quot;adjunto&quot; de <span>$c_i$</span>. Para derivar <span>$f$</span> respecto de <span>$a$</span>, se sigue el grafo desde el final hasta el principio, aplicando esta relación recursiva.</p><p>En el caso de la acumulación reversa, solo se debe hacer una corrida hacia adelante (en comparación con las <span>$n$</span> corridas necesarias en la acumulación hacia adelante para computar un gradiente en dimensión <span>$n$</span>), pero se deben tener todas las en memoria la relación entre cada variable intermedia y su derivada respecto de los nodos &quot;hijos&quot; en el grafo, que fueron calculadas en el paso hacia adelante. Si el grafo es grande (número de inputs mucho mayor que de outputs), el requerimiento de memoria puede ser excesivo.</p><p>Ejemplo:</p><p><img src="../Figures/ejemplo_backward_pass.png" alt="Grafo computacional: Reverse accumulation"/></p><p>Ejemplo: <span>$f(x_1,x_2)=x_1 x_2 + \sin x_1$</span></p><p><img src="../Figures/Wiki_ReverseaccumulationAD.png" alt="Grafo computacional: Reverse accumulation (Wiki)"/></p><p>Implementación en Julia de la diferenciación automática de <span>$f(a,b) = \ln(ab+\max(a, 2))$</span> para <span>$a=3$</span>, <span>$b=2$</span> con el método de acumulación reversa:</p><pre><code class="language-julia hljs">using Zygote: gradient

f(a, b) = log(a*b + max(a,2))

gradient(f, 3.0, 2.0) # Reverse Accumulation</code></pre><h3 id="Link-recomendado:"><a class="docs-heading-anchor" href="#Link-recomendado:">Link recomendado:</a><a id="Link-recomendado:-1"></a><a class="docs-heading-anchor-permalink" href="#Link-recomendado:" title="Permalink"></a></h3><p><a href="https://www.youtube.com/watch?v=wG_nF1awSSY">&quot;What is Automatic Differentiation?&quot;</a></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Computacion_numerica/">« Computación numérica</a><a class="docs-footer-nextpage" href="../../Fundamentos/Tipos de datos basicos/">Tipos de datos básicos »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 31 March 2023 21:44">Friday 31 March 2023</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
